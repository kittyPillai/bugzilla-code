.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Random::ISAAC 3"
.TH Math::Random::ISAAC 3 "2011-02-18" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Random::ISAAC \- Perl interface to the ISAAC PRNG algorithm
.SH "VERSION"
.IX Header "VERSION"
version 1.004
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Math::Random::ISAAC;
\&
\&  my $rng = Math::Random::ISAAC\->new(@seeds);
\&
\&  for (0..30) {
\&    print \*(AqResult: \*(Aq . $rng\->irand() . "\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As with other Pseudo-Random Number Generator (\s-1PRNG\s0) algorithms like the
Mersenne Twister (see Math::Random::MT), this algorithm is designed to
take some seed information and produce seemingly random results as output.
.PP
However, \s-1ISAAC \s0(Indirection, Shift, Accumulate, Add, and Count) has different
goals than these commonly used algorithms. In particular, it's really fast \-
on average, it requires only 18.75 machine cycles to generate a 32\-bit value.
This makes it suitable for applications where a significant amount of random
data needs to be produced quickly, such solving using the Monte Carlo method
or for games.
.PP
The results are uniformly distributed, unbiased, and unpredictable unless
you know the seed. The algorithm was published by Bob Jenkins in the late
90s and despite the best efforts of many security researchers, no feasible
attacks have been found to date.
.SS "\s-1USAGE WARNING\s0"
.IX Subsection "USAGE WARNING"
There was no method supplied to provide the initial seed data by the author.
On his web site, Bob Jenkins writes:
.PP
.Vb 2
\&  Seeding a random number generator is essentially the same problem as
\&  encrypting the seed with a block cipher.
.Ve
.PP
In the same spirit, by default, this module does not seed the algorithm at
all \*(-- it simply fills the state with zeroes \*(-- if no seed is provided.
The idea is to remind users that selecting good seed data for their purpose
is important, and for the module to conveniently set it to something like
\&\f(CW\*(C`localtime\*(C'\fR behind-the-scenes hurts users in the long run, since they don't
understand the limitations of doing so.
.PP
The type of seed you might want to use depends entirely on the purpose of
using this algorithm in your program in the first place. Here are some
possible seeding methods:
.IP "1 Math::TrulyRandom" 4
.IX Item "1 Math::TrulyRandom"
The Math::TrulyRandom module provides a way of obtaining truly random
data by using timing interrupts. This is probably one of the better ways
to seed the algorithm.
.IP "2 /dev/random" 4
.IX Item "2 /dev/random"
Using the system random device is, in principle, the best idea, since it
gathers entropy from various sources including interrupt timing, other
device interrupts, etc. However, it's not portable to anything other than
Unix-like platforms, and might not produce good data on some systems.
.IP "3 \fIlocaltime()\fR" 4
.IX Item "3 localtime()"
This works for basic things like simulations, but results in not-so-random
output, especially if you create new instances quickly (as the seeds would
be the same within per-second resolution).
.IP "4 Time::HiRes" 4
.IX Item "4 Time::HiRes"
In theory, using Time::HiRes is the same as option (2), but you get a
higher resolution time so you're less likely to have the same seed twice.
Note that you need to transform the output into an integer somehow, perhaps
by taking the least significant bits or using a hash function. This would
be less prone to duplicate instances, but it's still not ideal.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  Math::Random::ISAAC\->new( @seeds )
.Ve
.PP
Creates a \f(CW\*(C`Math::Random::ISAAC\*(C'\fR object, based upon either the optimized
C/XS version of the algorithm, Math::Random::ISAAC::XS, or falls back
to the included Pure Perl module, Math::Random::ISAAC::PP.
.PP
Example code:
.PP
.Vb 1
\&  my $rng = Math::Random::ISAAC\->new(time);
.Ve
.PP
This method will return an appropriate \fBMath::Random::ISAAC\fR object or
throw an exception on error.
.SS "rand"
.IX Subsection "rand"
.Vb 1
\&  $rng\->rand()
.Ve
.PP
Returns a random double-precision floating point number which is normalized
between 0 and 1 (inclusive; it's a closed interval).
.PP
Internally, this simply takes the uniformly distributed unsigned integer from
\&\f(CW\*(C`$rng\->irand()\*(C'\fR and divides it by \f(CW\*(C`2**32\-1\*(C'\fR (maximum unsigned integer
size)
.PP
Example code:
.PP
.Vb 1
\&  my $next = $rng\->rand();
.Ve
.PP
This method will return a double-precision floating point number or throw an
exception on error.
.SS "irand"
.IX Subsection "irand"
.Vb 1
\&  $rng\->irand()
.Ve
.PP
Returns the next unsigned 32\-bit random integer. It will return a value with
a value such that: \fB0 <= x <= 2**32\-1\fR.
.PP
Example code:
.PP
.Vb 1
\&  my $next = $rng\->irand();
.Ve
.PP
This method will return a 32\-bit unsigned integer or throw an exception on
error.
.SH "PURPOSE"
.IX Header "PURPOSE"
The intent of this module is to provide single simple interface to the two
compatible implementations of this module, namely, Math::Random::ISAAC::XS
and Math::Random::ISAAC::PP.
.PP
If, for some reason, you need to determine what version of the module is
actually being included by \f(CW\*(C`Math::Random::ISAAC\*(C'\fR, then:
.PP
.Vb 1
\&  print \*(AqBackend type: \*(Aq, $Math::Random::ISAAC::DRIVER, "\en";
.Ve
.PP
In order to force use of one or the other, simply load the appropriate module:
.PP
.Vb 5
\&  use Math::Random::ISAAC::XS;
\&  my $rng = Math::Random::ISAAC::XS\->new();
\&  # or
\&  use Math::Random::ISAAC::PP;
\&  my $rng = Math::Random::ISAAC::PP\->new();
.Ve
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.IP "\(bu" 4
Special thanks to Bob Jenkins <bob_jenkins@burtleburtle.net> for
devising this very clever algorithm and releasing it into the public domain.
.IP "\(bu" 4
Thanks to John L. Allen (contact unknown) for providing a Perl port of the
original \s-1ISAAC\s0 code, upon which \f(CW\*(C`Math::Random::ISAAC::PP\*(C'\fR is heavily based.
His version is available on Bob's web site, in the \s-1SEE ALSO\s0 section.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::Random::ISAAC::XS, the C/XS optimized version of this module, which
will be used automatically if available.
.PP
<http://burtleburtle.net/bob/rand/isaacafa.html>, Bob Jenkins' page about
\&\s-1ISAAC,\s0 which explains the algorithm as well as potential attacks.
.PP
<http://eprint.iacr.org/2006/438.pdf>, a paper entitled \*(L"On the pseudo-random
generator \s-1ISAAC,\*(R"\s0 which claims there are many seeds which will produce
non-uniform results. The author, Jean-Philippe Aumasson, argues \s-1ISAAC\s0 should
be using rotations (circular shifts) instead of normal shifts to increase
diffusion of the state, among other things.
.PP
<http://eprint.iacr.org/2001/049.pdf>, a paper by Marina Pudovkina discussing
plaintext attacks on the \s-1ISAAC\s0 keystream generator. Among other things, it
notes that the time complexity is \fBTmet = 4.67*10^1240\fR, so it remains a
secure cipher for practical applications.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\(bu" 4
There is no method that allows re-seeding of algorithms. This is not really
necessary because one can simply call \f(CW\*(C`new\*(C'\fR again with the new seed data
periodically.
.Sp
But he also provides a simple workaround:
.Sp
.Vb 4
\&  As ISAAC is intended to be a secure cipher, if you want to reseed it,
\&  one way is to use some other cipher to seed some initial version of ISAAC,
\&  then use ISAAC\*(Aqs output as a seed for other instances of ISAAC whenever
\&  they need to be reseeded.
.Ve
.IP "\(bu" 4
There is no way to clone a \s-1PRNG\s0 instance. I'm not sure why this is might
even be necessary or useful. File a bug report with an explanation why and
I'll consider adding it to the next release.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Math\-Random\-ISAAC
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jonathan Yu <jawnsy@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Legally speaking, this package and its contents are:
.PP
.Vb 1
\&  Copyright (c) 2011 by Jonathan Yu <jawnsy@cpan.org>.
.Ve
.PP
But this is really just a legal technicality that allows the author to
offer this package under the public domain and also a variety of licensing
options. For all intents and purposes, this is public domain software,
which means you can do whatever you want with it.
.PP
The software is provided \*(L"\s-1AS IS\*(R",\s0 without warranty of any kind, express or
implied, including but not limited to the warranties of merchantability,
fitness for a particular purpose and noninfringement. In no event shall the
authors or copyright holders be liable for any claim, damages or other
liability, whether in an action of contract, tort or otherwise, arising from,
out of or in connection with the software or the use or other dealings in
the software.
