.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Linux::Smaps 3"
.TH Linux::Smaps 3 "2013-05-21" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Linux::Smaps \- a Perl interface to /proc/PID/smaps
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Linux::Smaps;
\&  my $map=Linux::Smaps\->new($pid);
\&  my @vmas=$map\->vmas;
\&  my $private_dirty=$map\->private_dirty;
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fI/proc/PID/smaps\fR files in modern linuxes provides very detailed
information about a processes memory consumption. It particularly includes
a way to estimate the effect of copy-on-write. This module implements a Perl
interface.
.PP
The content of the \fIsmaps\fR file is a set of blocks like this:
.PP
.Vb 12
\& 0060a000\-0060b000 r\-\-p 0000a000 fd:01 531212       /bin/cat
\& Size:                  4 kB
\& Rss:                   4 kB
\& Pss:                   4 kB
\& Shared_Clean:          0 kB
\& Shared_Dirty:          0 kB
\& Private_Clean:         0 kB
\& Private_Dirty:         4 kB
\& Referenced:            4 kB
\& Swap:                  0 kB
\& KernelPageSize:        4 kB
\& MMUPageSize:           4 kB
.Ve
.PP
Each one describes a virtual memory area of a certain process. All those
areas together describe its complete address space. For the meaning of
the items refer to your Linux documentation.
.PP
The set of information announced by the kernel depends on its version. Early
versions (around Linux 2.6.14) lacked for example \f(CW\*(C`Pss\*(C'\fR, \f(CW\*(C`Referenced\*(C'\fR,
\&\f(CW\*(C`Swap\*(C'\fR, \f(CW\*(C`KernelPageSize\*(C'\fR and \f(CW\*(C`MMUPageSize\*(C'\fR. \f(CW\*(C`Linux::Smaps\*(C'\fR provides an
interface to all of the components. It creates accessor methods dynamically
depending on what the kernel reveals. The \f(CW\*(C`Shared_Clean\*(C'\fR entry for example
mutates to the \f(CW\*(C`Linux::Smaps::VMA\->shared_clean\*(C'\fR accessor. Method
names are built by simply lowercasing them. The actual set of methods is
created when the first \fIsmaps\fR file is parsed. Subsequent \f(CW\*(C`update\*(C'\fR
or \f(CW\*(C`Linux::Smaps\->new\*(C'\fR operations expect exactly the same file format.
That means you cannot parse \fIsmaps\fR files from different kernel versions
by the same perl interpreter.
.SS "Constructor, Object Initialization, etc."
.IX Subsection "Constructor, Object Initialization, etc."
\fILinux::Smaps\->new\fR
.IX Subsection "Linux::Smaps->new"
.PP
\fILinux::Smaps\->new($pid)\fR
.IX Subsection "Linux::Smaps->new($pid)"
.PP
\fILinux::Smaps\->new(pid=>$pid, procdir=>'/proc')\fR
.IX Subsection "Linux::Smaps->new(pid=>$pid, procdir=>'/proc')"
.PP
\fILinux::Smaps\->new(filename=>'/proc/self/smaps')\fR
.IX Subsection "Linux::Smaps->new(filename=>'/proc/self/smaps')"
.PP
creates and initializes a \f(CW\*(C`Linux::Smaps\*(C'\fR object. On error an exception is
thrown. \f(CW\*(C`new()\*(C'\fR may fail if the smaps file is not readable or if the file
format is wrong.
.PP
\&\f(CW\*(C`new()\*(C'\fR without parameter is equivalent to \f(CW\*(C`new(\*(Aqself\*(Aq)\*(C'\fR or
\&\f(CW\*(C`new(pid=>\*(Aqself\*(Aq)\*(C'\fR. With the \f(CW\*(C`procdir\*(C'\fR parameter the mount point of
the proc filesystem can be set if it differs from the standard \f(CW\*(C`/proc\*(C'\fR.
.PP
The \f(CW\*(C`filename\*(C'\fR parameter sets the name of the smaps file directly. This way
also files outside the standard \f(CW\*(C`/proc\*(C'\fR tree can be analyzed.
.PP
\fILinux::Smaps\->new(uninitialized=>1)\fR
.IX Subsection "Linux::Smaps->new(uninitialized=>1)"
.PP
returns an uninitialized object. This makes \f(CW\*(C`new()\*(C'\fR simply skip the \f(CW\*(C`update()\*(C'\fR
call after setting all parameters. Additional parameters like \f(CW\*(C`pid\*(C'\fR,
\&\f(CW\*(C`procdir\*(C'\fR or \f(CW\*(C`filename\*(C'\fR can be passed.
.PP
\fI\f(CI$self\fI\->pid($pid) or \f(CI$self\fI\->pid=$pid\fR
.IX Subsection "$self->pid($pid) or $self->pid=$pid"
.PP
\fI\f(CI$self\fI\->procdir($dir) or \f(CI$self\fI\->procdir=$dir\fR
.IX Subsection "$self->procdir($dir) or $self->procdir=$dir"
.PP
\fI\f(CI$self\fI\->filename($name) or \f(CI$self\fI\->filename=$name\fR
.IX Subsection "$self->filename($name) or $self->filename=$name"
.PP
get/set parameters.
.PP
If a filename is set \f(CW\*(C`update()\*(C'\fR reads that file. Otherwize a file name is
constructed from \f(CW\*(C`$self\->procdir\*(C'\fR, \f(CW\*(C`$self\->pid\*(C'\fR and the name
\&\f(CW\*(C`smaps\*(C'\fR. The constructed file name is not saved in the \f(CW\*(C`Linux::Smaps\*(C'\fR
object to allow loops like this:
.PP
.Vb 5
\& foreach (@pids) {
\&     $smaps\->pid=$_;
\&     $smaps\->update;
\&     process $smaps;
\& }
.Ve
.PP
\fI\f(CI$self\fI\->update\fR
.IX Subsection "$self->update"
.PP
reinitializes the object; rereads the underlying file. Returns the object
or \f(CW\*(C`undef\*(C'\fR on error. The actual reason can be obtained via \f(CW\*(C`lasterror()\*(C'\fR.
.PP
\fI\f(CI$self\fI\->clear_refs\fR
.IX Subsection "$self->clear_refs"
.PP
writes to the corresponding \fI/proc/PID/clear_refs\fR file. Thus, the amount
of memory reported as \f(CW\*(C`Referenced\*(C'\fR by the process is reset to \f(CW0\fR for
all VMAs.
.PP
Returns the object or \f(CW\*(C`undef\*(C'\fR on failure.
.PP
Example:
.PP
.Vb 8
\& # how much memory is referenced while updating the Linux::Smaps object?
\& perl \-MLinux::Smaps \-le \*(Aq
\&   my $s=Linux::Smaps\->new;
\&   print $s\->referenced;
\&   print $s\->clear_refs\->update\->referenced
\& \*(Aq
\& 2556
\& 840
\&
\& # how much memory is used while the shell is inactive?
\& perl \-MLinux::Smaps \-le \*(Aq
\&   my $s=Linux::Smaps\->new(shift);
\&   print $s\->referenced;
\&   print $s\->clear_refs\->update\->referenced
\& \*(Aq $$
\& 1468
\& 0
.Ve
.PP
\fI\f(CI$self\fI\->lasterror\fR
.IX Subsection "$self->lasterror"
.PP
\&\f(CW\*(C`update()\*(C'\fR and \f(CW\*(C`new()\*(C'\fR return \f(CW\*(C`undef\*(C'\fR on failure. \f(CW\*(C`lasterror()\*(C'\fR returns
a more verbose reason. Also \f(CW$!\fR can be checked.
.SS "Information Retrieval"
.IX Subsection "Information Retrieval"
\fI\f(CI$self\fI\->vmas\fR
.IX Subsection "$self->vmas"
.PP
returns a list of \f(CW\*(C`Linux::Smaps::VMA\*(C'\fR objects each describing a vm area,
see below.
.PP
\fI\f(CI$self\fI\->size\fR
.IX Subsection "$self->size"
.PP
\fI\f(CI$self\fI\->rss\fR
.IX Subsection "$self->rss"
.PP
\fI\f(CI$self\fI\->shared_clean\fR
.IX Subsection "$self->shared_clean"
.PP
\fI\f(CI$self\fI\->shared_dirty\fR
.IX Subsection "$self->shared_dirty"
.PP
\fI\f(CI$self\fI\->private_clean\fR
.IX Subsection "$self->private_clean"
.PP
\fI\f(CI$self\fI\->private_dirty\fR
.IX Subsection "$self->private_dirty"
.PP
these methods compute the sums of the corresponding values of all vmas.
.PP
\&\f(CW\*(C`size\*(C'\fR, \f(CW\*(C`rss\*(C'\fR, \f(CW\*(C`shared_clean\*(C'\fR, \f(CW\*(C`shared_dirty\*(C'\fR, \f(CW\*(C`private_clean\*(C'\fR and
\&\f(CW\*(C`private_dirty\*(C'\fR methods are unknown until the first call to
\&\f(CW\*(C`Linux::Smaps::update()\*(C'\fR. They are created on the fly. This is to make
the module extendable as new features are added to the smaps file by the
kernel. As long as the corresponding smaps file lines match
\&\f(CW\*(C`^(\ew+):\es*(\ed+) kB$\*(C'\fR new accessor methods are created.
.PP
At the time of this writing at least one new field (\f(CW\*(C`referenced\*(C'\fR) is on
the way but all my kernels still lack it.
.PP
\fI\f(CI$self\fI\->stack\fR
.IX Subsection "$self->stack"
.PP
\fI\f(CI$self\fI\->heap\fR
.IX Subsection "$self->heap"
.PP
\fI\f(CI$self\fI\->vdso\fR
.IX Subsection "$self->vdso"
.PP
\fI\f(CI$self\fI\->vsyscall\fR
.IX Subsection "$self->vsyscall"
.PP
these are shortcuts to the corresponding \f(CW\*(C`Linux::Smaps::VMA\*(C'\fR objects.
.PP
\fI\f(CI$self\fI\->all\fR
.IX Subsection "$self->all"
.PP
\fI\f(CI$self\fI\->named\fR
.IX Subsection "$self->named"
.PP
\fI\f(CI$self\fI\->unnamed\fR
.IX Subsection "$self->unnamed"
.PP
In array context these functions return a list of \f(CW\*(C`Linux::Smaps::VMA\*(C'\fR
objects representing named or unnamed VMAs or simply all VMAs. Thus, in
array context \f(CW\*(C`all()\*(C'\fR is equivalent to \f(CW\*(C`vmas()\*(C'\fR.
.PP
In scalar context these functions create a fake \f(CW\*(C`Linux::Smaps::VMA\*(C'\fR object
containing the summaries of the \f(CW\*(C`size\*(C'\fR, \f(CW\*(C`rss\*(C'\fR, \f(CW\*(C`shared_clean\*(C'\fR,
\&\f(CW\*(C`shared_dirty\*(C'\fR, \f(CW\*(C`private_clean\*(C'\fR and \f(CW\*(C`private_dirty\*(C'\fR fields.
.PP
\fI\f(CI$self\fI\->names\fR
.IX Subsection "$self->names"
.PP
returns a list of vma names, i.e. the files that are mapped.
.PP
\fI($new, \f(CI$diff\fI, \f(CI$old\fI)=$self\->diff( \f(CI$other\fI )\fR
.IX Subsection "($new, $diff, $old)=$self->diff( $other )"
.PP
\&\f(CW$other\fR is assumed to be also a \f(CW\*(C`Linux::Smaps\*(C'\fR instance. 3 arrays are
returned. The first one ($new) is a list of vmas that are contained in
\&\f(CW$self\fR but not in \f(CW$other\fR. The second one ($diff) contains a list of pairs
(2\-element arrays) of vmas that differ between \f(CW$self\fR and \f(CW$other\fR. The
3rd one ($old) is a list of vmas that are contained in \f(CW$other\fR but not in
\&\f(CW$self\fR.
.PP
Vmas are identified as corresponding if their \f(CW\*(C`vma_start\*(C'\fR fields match.
They are considered different if they differ in one of the following fields:
\&\f(CW\*(C`vma_end\*(C'\fR, \f(CW\*(C`r\*(C'\fR, \f(CW\*(C`w\*(C'\fR, \f(CW\*(C`x\*(C'\fR, \f(CW\*(C`mayshare\*(C'\fR, \f(CW\*(C`file_off\*(C'\fR, \f(CW\*(C`dev_major\*(C'\fR,
\&\f(CW\*(C`dev_minor\*(C'\fR, \f(CW\*(C`inode\*(C'\fR, \f(CW\*(C`file_name\*(C'\fR, \f(CW\*(C`shared_clean\*(C'\fR, \f(CW\*(C`shared_diry\*(C'\fR,
\&\f(CW\*(C`private_clean\*(C'\fR and \f(CW\*(C`private_dirty\*(C'\fR.
.ie n .SS """Linux::Smaps::VMA"" objects"
.el .SS "\f(CWLinux::Smaps::VMA\fP objects"
.IX Subsection "Linux::Smaps::VMA objects"
normally these objects represent a single vm area:
.PP
\fI\f(CI$self\fI\->vma_start\fR
.IX Subsection "$self->vma_start"
.PP
\fI\f(CI$self\fI\->vma_end\fR
.IX Subsection "$self->vma_end"
.PP
start and end address
.PP
\fI\f(CI$self\fI\->r\fR
.IX Subsection "$self->r"
.PP
\fI\f(CI$self\fI\->w\fR
.IX Subsection "$self->w"
.PP
\fI\f(CI$self\fI\->x\fR
.IX Subsection "$self->x"
.PP
\fI\f(CI$self\fI\->mayshare\fR
.IX Subsection "$self->mayshare"
.PP
these correspond to the \s-1VM_READ, VM_WRITE, VM_EXEC\s0 and \s-1VM_MAYSHARE\s0 flags.
see Linux kernel for more information.
.PP
\fI\f(CI$self\fI\->file_off\fR
.IX Subsection "$self->file_off"
.PP
\fI\f(CI$self\fI\->dev_major\fR
.IX Subsection "$self->dev_major"
.PP
\fI\f(CI$self\fI\->dev_minor\fR
.IX Subsection "$self->dev_minor"
.PP
\fI\f(CI$self\fI\->inode\fR
.IX Subsection "$self->inode"
.PP
\fI\f(CI$self\fI\->file_name\fR
.IX Subsection "$self->file_name"
.PP
describe the file area that is mapped.
.PP
\fI\f(CI$self\fI\->size\fR
.IX Subsection "$self->size"
.PP
the same as vma_end \- vma_start but in kB.
.PP
\fI\f(CI$self\fI\->rss\fR
.IX Subsection "$self->rss"
.PP
what part is resident.
.PP
\fI\f(CI$self\fI\->shared_clean\fR
.IX Subsection "$self->shared_clean"
.PP
\fI\f(CI$self\fI\->shared_dirty\fR
.IX Subsection "$self->shared_dirty"
.PP
\fI\f(CI$self\fI\->private_clean\fR
.IX Subsection "$self->private_clean"
.PP
\fI\f(CI$self\fI\->private_dirty\fR
.IX Subsection "$self->private_dirty"
.PP
\&\f(CW\*(C`shared\*(C'\fR means \f(CW\*(C`page_count(page)>=2\*(C'\fR (see Linux kernel), i.e. the page
is shared between several processes. \f(CW\*(C`private\*(C'\fR pages belong only to one
process.
.PP
\&\f(CW\*(C`dirty\*(C'\fR pages are written to in \s-1RAM\s0 but not to the corresponding file.
.SS "Notes"
.IX Subsection "Notes"
\&\f(CW\*(C`size\*(C'\fR, \f(CW\*(C`rss\*(C'\fR, \f(CW\*(C`shared_clean\*(C'\fR, \f(CW\*(C`shared_dirty\*(C'\fR, \f(CW\*(C`private_clean\*(C'\fR and
\&\f(CW\*(C`private_dirty\*(C'\fR methods are unknown until the first call to
\&\f(CW\*(C`Linux::Smaps::update\*(C'\fR. They are created on the fly. This is to make
the module extendable as new features are added to the smaps file by the
kernel. As long as the corresponding smaps file lines match
\&\f(CW\*(C`^(\ew+):\es*(\ed+) kB$\*(C'\fR new accessor methods are created.
.PP
See also \*(L"\s-1EXPORT\*(R"\s0 below.
.SH "Example: The copy-on-write effect"
.IX Header "Example: The copy-on-write effect"
.Vb 2
\& use strict;
\& use Linux::Smaps;
\&
\& my $x="a"x(1024*1024);         # a long string of "a"
\& if( fork ) {
\&   my $s=Linux::Smaps\->new($$);
\&   my $before=$s\->all;
\&   $x=~tr/a/b/;                 # change "a" to "b" in place
\&   #$x="b"x(1024*1024);         # assignment
\&   $s\->update;
\&   my $after=$s\->all;
\&   foreach my $n (qw{rss size shared_clean shared_dirty
\&                     private_clean private_dirty}) {
\&     print "$n: ",$before\->$n," => ",$after\->$n,": ",
\&            $after\->$n\-$before\->$n,"\en";
\&   }
\&   wait;
\& } else {
\&   sleep 1;
\& }
.Ve
.PP
This script may give the following output:
.PP
.Vb 6
\& rss: 4160 => 4252: 92
\& size: 6916 => 7048: 132
\& shared_clean: 1580 => 1596: 16
\& shared_dirty: 2412 => 1312: \-1100
\& private_clean: 0 => 0: 0
\& private_dirty: 168 => 1344: 1176
.Ve
.PP
\&\f(CW$x\fR is changed in place. Hence, the overall process size (size and rss)
would not grow much. But before the \f(CW\*(C`tr\*(C'\fR operation \f(CW$x\fR was shared by
copy-on-write between the 2 processes. Hence, we see a loss of \f(CW\*(C`shared_dirty\*(C'\fR
(only a little more than our 1024 kB string) and almost the same growth of
\&\f(CW\*(C`private_dirty\*(C'\fR.
.PP
Exchanging the \f(CW\*(C`tr\*(C'\fR\-operation to an assingment of a \s-1MB\s0 of \*(L"b\*(R" yields the
following figures:
.PP
.Vb 6
\& rss: 4160 => 5276: 1116
\& size: 6916 => 8076: 1160
\& shared_clean: 1580 => 1592: 12
\& shared_dirty: 2432 => 1304: \-1128
\& private_clean: 0 => 0: 0
\& private_dirty: 148 => 2380: 2232
.Ve
.PP
Now we see the overall process size grows a little more than a \s-1MB.
\&\s0\f(CW\*(C`shared_dirty\*(C'\fR drops almost a \s-1MB\s0 and \f(CW\*(C`private_dirty\*(C'\fR adds almost 2 \s-1MB.\s0
That means perl first constructs a 1 \s-1MB\s0 string of \f(CW\*(C`b\*(C'\fR. This adds 1 \s-1MB\s0 to
\&\f(CW\*(C`size\*(C'\fR, \f(CW\*(C`rss\*(C'\fR and \f(CW\*(C`private_dirty\*(C'\fR and then copies it to \f(CW$x\fR. This
takes another \s-1MB\s0 from \f(CW\*(C`shared_dirty\*(C'\fR and adds it to \f(CW\*(C`private_dirty\*(C'\fR.
.SH "A special note on copy on write measurements"
.IX Header "A special note on copy on write measurements"
The proc filesystem reports a page as shared if it belongs multiple
processes and as private if it belongs to only one process. But there
is an exception. If a page is currently paged out (that means it is not
in core) all its attributes including the reference count are paged out
as well. So the reference count cannot be read without paging in the page.
In this case a page is neither reported as private nor as shared. It is
only included in the process size.
.PP
Thus, to exaclty measure which pages are shared among N processes at least
one of them must be completely in core. This way all pages that can
possibly be shared are in core and their reference counts are accessible.
.PP
The \fImlockall\fR\|(2) syscall may help in this situation. It locks all pages
of a process to main memory:
.PP
.Vb 2
\& require \*(Aqsyscall.ph\*(Aq;
\& require \*(Aqsys/mmap.ph\*(Aq;
\&
\& 0==syscall &SYS_mlockall, &MCL_CURRENT | &MCL_FUTURE or
\&     die "ERROR: mlockall failed: $!\en";
.Ve
.PP
This snippet in one of the processes locks it to the main memory. If all
processes are created from the same parent it is executed best just before
the parent starts to fork off children. The memory lock is not inherited
by the children. So all private pages of the children are swappable.
.SH "EXPORT"
.IX Header "EXPORT"
The module's \f(CW\*(C`import()\*(C'\fR method is implemented as follows:
.PP
.Vb 8
\& my $once;
\& sub import {
\&   my $class=shift;
\&   unless( $once ) {
\&     $once=1;
\&     eval {$class\->new(@_)};
\&   }
\& }
.Ve
.PP
Thus, the first
.PP
.Vb 1
\& use Linux::Smaps;
.Ve
.PP
initializes all methods according to your current kernel.
.PP
To avoid that use
.PP
.Vb 1
\& use Linux::Smaps ();
.Ve
.PP
If your \f(CW\*(C`proc\*(C'\fR filesystem is mounted elsewhere or if you want to initialize
the methods according to a certain file you can achieve this by
.PP
.Vb 1
\& use Linux::Smaps (procdir=>\*(Aq/procfs\*(Aq);
.Ve
.PP
or
.PP
.Vb 1
\& use Linux::Smaps (filename=>\*(Aq/path\*(Aq);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Linux Kernel.
.SH "AUTHOR"
.IX Header "AUTHOR"
Torsten Foertsch, <torsten.foertsch@gmx.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005\-2011 by Torsten Foertsch
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.5 or,
at your option, any later version of Perl 5 you may have available.
