.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Event 3"
.TH Event 3 "2009-08-25" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Event \- Event loop processing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Event qw(loop unloop);
\& 
\& # initialize application
\& Event\->flavor(attribute => value, ...);
\&    
\& my $ret = loop();
\&    
\& # and some callback will call
\& unloop(\*(Aqok\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1ALERT:\s0 Marc Lehmann may have taken over the future of event loops in
Perl. Check out his libev library and \s-1EV\s0 Perl module. 25 Aug 2009
.PP
The Event module provide a central facility to watch for various types
of events and invoke a callback when these events occur.  The idea is
to delay the handling of events so that they may be dispatched in
priority order when it is safe for callbacks to execute.
.PP
Events (in the ordinary sense of the word) are detected by \fBwatchers\fR,
which reify them as \fBevents\fR (in the special Event module sense).
For clarity,
the former type of events may be called \*(L"source events\*(R", and the latter
\&\*(L"target events\*(R".  Source events, such as signals arriving, happen whether
or not they are being watched.  If a source event occurs which a
watcher is actively watching then the watcher generates a corresponding
target event.  Target events are only created by watchers.  If several
watchers are interested in the same source event then each will
generate their own target event.  Hence, any particular source event may
result in zero, one, two, or any number of target events: the same as
the number of watchers which were actively watching for it.
.PP
Target events are queued to be processed in priority order (priority
being determined by the creating watcher) and in \s-1FIFO\s0 order among events
of the same priority.  Queued (\*(L"pending\*(R") events can, in some cases, be
cancelled before being processed.  A queued event is processed by being
passed to the callback function (or method on a particular object or class)
which was specified to the watcher.
.PP
A watcher, once created, operates autonomously without the Event user
having to retain any reference to it.  However, keeping a reference
makes it possible to modify most of the watcher's characteristics.
A watcher can be switched between active and inactive states. When
inactive, it does not generate target events.
.PP
Some types of source event are not reified as target events immediately.
Signals received, for example, are counted initially. The
counted signals are reified at certain execution points.
Hence, signal events may be processed out of order, and if handled
carelessly, on the wrong side of a state change in event handling.
A useful way to view this is that occurrence of the source
event is not actually the arrival of the signal but is triggered by the
counting of the signal.
.PP
Reification can be forced when necessary.
The schedule on which some other events are created is
non-obvious.  This is especially the case with watchers that
watch for a condition rather than an event.  In some cases,
target events are generated on a schedule that depends on the
operation of the event loop.
.SH "PERL API"
.IX Header "PERL API"
Events (the occurrence of such) are noticed and queued by 'event
watchers'.  The creation and configuration of event watchers is the
primary topic of the rest of this document.
.PP
The following functions control or interrogate the event loop as a
whole:
.ie n .IP "$result = loop([$timeout])" 4
.el .IP "\f(CW$result\fR = loop([$timeout])" 4
.IX Item "$result = loop([$timeout])"
Will enter a loop that calls \fIone_event()\fR until \fIunloop()\fR is called.
The argument passed to \fIunloop()\fR is the return value of \fIloop()\fR.  Loops
can be nested.
.IP "unloop($result)" 4
.IX Item "unloop($result)"
Make the inner-most \fIloop()\fR return with \f(CW$result\fR.
.IP "unloop_all($result)" 4
.IX Item "unloop_all($result)"
Cause all pending \fIloop()\fRs to return immediately.  This is \fBnot\fR
implemented with \f(CW\*(C`die\*(C'\fR.  It is works as if \f(CW\*(C`unloop($result)\*(C'\fR were
called for all nested loops.
.IP "sweep([$max_prio])" 4
.IX Item "sweep([$max_prio])"
Queue all pending events and dispatch any with priority strictly less
than \f(CW$max_prio\fR (the highest priority is 0).  The default is to process
all events except idle events.  (While idle \fBevents\fR are ignored by
sweep, idle watchers are \fBnot\fR ignored.  If you want to avoid
triggering an idle watcher then set \f(CW\*(C`max\*(C'\fR to \f(CW\*(C`undef\*(C'\fR or \f(CW\*(C`stop()\*(C'\fR it.)
.IP "one_event([$timeout])" 4
.IX Item "one_event([$timeout])"
If any events are outstanding then invoke the corresponding callback
of the highest priority event.  If there are no events available,
block forever or until \f(CW$timeout\fR.  Use of this \s-1API\s0 is not recommended
because it is not efficient and does not trap exceptions.  However,
you might wish to understand how it works:
.RS 4
.IP "1." 4
Queue asyncronous events (signals, etc).  That is, previously recorded
events are reified.
.IP "2." 4
If there are any events with priority 5 or less (see StarvePrio) then
service the next one and return.
.IP "3." 4
Calculate the maximum wait time (minimum time till the next timer
expiration) and pass control to the poll/select system call.  Upon
return, queue all pending events.
.IP "4." 4
Queue asyncronous events again.
.IP "5." 4
If there are any events then service the next one and return.
.IP "6." 4
Service the next idle watcher.
.RE
.RS 4
.Sp
StarvePrio is the priority level for which events are dispatched
during step 2.  It cannot be changed without a recompile.  In the rare
case that an event is always pending at step 2 then I/O watchers will
starve.  However, this is highly unlikely since async watchers should
never queue events so rapidly.
.RE
.IP "\fIall_watchers()\fR" 4
.IX Item "all_watchers()"
Returns a list of all watchers (including stopped watchers).
.IP "\fIall_running()\fR" 4
.IX Item "all_running()"
Returns a list of all watchers with actively running callbacks.
Watchers are returned in order of most recent to least recent.
.IP "\fIall_idle()\fR" 4
.IX Item "all_idle()"
Returns a list of all the idle watchers.
If the event queue is very busy, all the idle watchers will sit on the
idle queue waiting to run.  However, be aware that if an idle watcher
has the \f(CW\*(C`max\*(C'\fR attribute set then it will queue a normal event when
its \f(CW\*(C`max\*(C'\fR wait time is exceeded.
.IP "\fIqueue_pending()\fR" 4
.IX Item "queue_pending()"
Examines asynchronous source events (timers & signals) and reifies
them as target events. \f(CW\*(C`queue_pending()\*(C'\fR is only called implicitly by
\&\f(CW\*(C`sweep()\*(C'\fR and \f(CW\*(C`one_event()\*(C'\fR.  Otherwise, \f(CW\*(C`queue_pending()\*(C'\fR is not
called implicitly.
.Sp
\&\s-1NOTE:\s0 Signal watchers generate target events according to which
watchers are active at the time that \f(CW\*(C`queue_pending()\*(C'\fR is called
rather than according to the time the signal is received.  This is
best explained by example.  See the file \f(CW\*(C`demo/queue_pending.t\*(C'\fR.
.SS "Event Watcher Constructors"
.IX Subsection "Event Watcher Constructors"
All watchers are constructed in one of the following ways:
.PP
.Vb 1
\&  $w = Event\->flavor( [attr1 => $value,]... );
\& 
\&  $w = Event::flavor($Class, [attr1 => $value,]...);
\&
\&  $w = Event::flavor\->new([attr1 => $value,]...);
.Ve
.PP
Where \fIflavor\fR is substituted with the kind of watcher.  Built-in
types include idle, io, signal, timer, and var.
.PP
New watchers (hopefully) have reasonable defaults and can also be
customized by passing extra attributes to the constructor.  When
created, watcher objects are \*(L"started\*(R" and are waiting for events
(see \f(CW\*(C`$event\->start\*(C'\fR below).
.PP
NetServer::Portal can display watchers in real-time, formatted
similarly to the popular \f(CW\*(C`top\*(C'\fR program.  You may find this a useful
aide for debugging.
.SS "Shared Watcher Attributes"
.IX Subsection "Shared Watcher Attributes"
Watchers are configured with attributes (also known as properties).
For example:
.PP
.Vb 1
\&   $watcher\->cb(\e&some_code);   # set callback
\&
\&   warn $event\->w\->desc.": ".$event\->hits." events happened; Wow!";
.Ve
.PP
All watchers support the following attributes: cb, cbtime, debug,
desc, prio, max_cb_tm, reentrant, and repeat.  Watcher constructors
accept the preceding and additionally: async and nice.
Moreover, watchers also offer extra
attributes according to their specialty.
.SS "Shared Watcher Methods"
.IX Subsection "Shared Watcher Methods"
The following methods are available for all watchers:
.ie n .IP "$watcher\->start" 4
.el .IP "\f(CW$watcher\fR\->start" 4
.IX Item "$watcher->start"
Activate the watcher.  Watchers refuse to \f(CW\*(C`start()\*(C'\fR without
sufficient configuration information to generate events.  Constructors
always invoke \f(CW\*(C`start()\*(C'\fR unless the \f(CW\*(C`parked=>1\*(C'\fR option is requested.
You will need to set the parked option if you preallocate unconfigured
watchers.
.Sp
Note: If there are any unreified asynchronous events that are of
interest to the watcher, it will see these events even though they
happened before it was started.  This affects signal watchers, but
there will only be existing unreified signal events if Event was
already handling the signal, which it would only do if there were
another active watcher for the same signal.  If this situation might
occur, and it would be a problem for the new watcher to see older
events, call \f(CW\*(C`queue_pending()\*(C'\fR immediately before starting the new
watcher in order to reify any outstanding events.  This explaination
may be more clear if read along with \f(CW\*(C`demo/queue_pending.t\*(C'\fR.
.ie n .IP "$watcher\->again" 4
.el .IP "\f(CW$watcher\fR\->again" 4
.IX Item "$watcher->again"
This is the same as the \f(CW\*(C`start\*(C'\fR except if a watcher has special
repeat behavior.  For example, repeating timers recalculate their alarm
time using the \f(CW\*(C`interval\*(C'\fR parameter.
.ie n .IP "$watcher\->now" 4
.el .IP "\f(CW$watcher\fR\->now" 4
.IX Item "$watcher->now"
Cause the watcher to generate an event, even if it is stopped.
The callback may or may not
run immediately depending upon the event's priority.  If you must
unconditionally invoke the callback, consider something like
.Sp
.Vb 1
\&  $w\->cb\->($w);
.Ve
.ie n .IP "$watcher\->stop" 4
.el .IP "\f(CW$watcher\fR\->stop" 4
.IX Item "$watcher->stop"
Don't look for events any more.  Running events are allowed to
complete but pending events are cancelled.  Note that a stopped
watcher can be reactivated by calling the \f(CW\*(C`start\*(C'\fR or \f(CW\*(C`again\*(C'\fR
methods.
.Sp
Watchers are stopped implicitly if their new configuration deprives
them of the ability to generate events.  For instance:
.Sp
.Vb 4
\&  my $io_watcher = Event\->io(timeout => 1);  # started
\&  $io_watcher\->timeout(undef);               # stopped implicitly
\&  $io_watcher\->timeout(1);                   # still stopped
\&  $io_watcher\->start;                        # restarted
.Ve
.ie n .IP "$watcher\->cancel" 4
.el .IP "\f(CW$watcher\fR\->cancel" 4
.IX Item "$watcher->cancel"
Stop and destroy \f(CW$watcher\fR.  Running events are allowed to complete
but pending events are cancelled.  Cancelled watchers are no longer
valid except for read-only operations.  For example, \fIprio()\fR can
return the watcher's priority, but \fIstart()\fR will fail.
.ie n .IP "$watcher\->is_cancelled" 4
.el .IP "\f(CW$watcher\fR\->is_cancelled" 4
.IX Item "$watcher->is_cancelled"
Reports whether the \f(CW$watcher\fR has been cancelled.
.ie n .IP "$watcher\->is_active" 4
.el .IP "\f(CW$watcher\fR\->is_active" 4
.IX Item "$watcher->is_active"
Reports whether the \f(CW$watcher\fR has been started.  The return value is
not affected by suspend.
.ie n .IP "$watcher\->is_running" 4
.el .IP "\f(CW$watcher\fR\->is_running" 4
.IX Item "$watcher->is_running"
Zero if the callback is not running.  Otherwise, the number of levels
that the callback has been entered.  This can be greater than one if a
\&\f(CW\*(C`reentrant\*(C'\fR callback invokes \f(CW\*(C`loop\*(C'\fR (or \f(CW\*(C`sweep\*(C'\fR, with lesser
probability).
.ie n .IP "$watcher\->is_suspended" 4
.el .IP "\f(CW$watcher\fR\->is_suspended" 4
.IX Item "$watcher->is_suspended"
Reports whether the \f(CW$watcher\fR is suspended.  Suspension is a debugging
feature; see the discussion of the \*(L"suspend\*(R" attribute below.
.ie n .IP "$watcher\->pending" 4
.el .IP "\f(CW$watcher\fR\->pending" 4
.IX Item "$watcher->pending"
In scalar context, returns a boolean indicating whether this watcher
has any events pending in the event queue.  In array context, returns
a list of all the watcher's pending events.
.Sp
Note that this does not check for unreified asynchronous events.  Call
\&\f(CW\*(C`queue_pending()\*(C'\fR first if you want to see signals received since the
last operation of the event loop.
.SS "Watcher Types"
.IX Subsection "Watcher Types"
.IP "idle" 4
.IX Item "idle"
Extra attributes: min => \f(CW$seconds\fR, max => \f(CW$seconds\fR
.Sp
Watches for the Event system to be idle, i.e., to have no events pending.
If the system is never idle, an event will be generated at least every
\&\f(CW\*(C`max\*(C'\fR seconds.  While Event is idle, events will be generated not more
often than \f(CW\*(C`min\*(C'\fR seconds.
.Sp
If neither \f(CW\*(C`min\*(C'\fR nor \f(CW\*(C`max\*(C'\fR is specified, the watcher defaults to
one-shot behaviour (\f(CW\*(C`repeat\*(C'\fR false), otherwise it defaults to repeating.
In either case, the default can be overidden by specifying a \f(CW\*(C`repeat\*(C'\fR
attribute.  \f(CW\*(C`min\*(C'\fR defaults to 0.01, and \f(CW\*(C`max\*(C'\fR defaults to infinity.
.IP "var" 4
.IX Item "var"
Extra attributes: var => \e$var, poll => 'rw'
.Sp
Var watchers generate events when the given variable is read from or
written to, as specified by \f(CW\*(C`poll\*(C'\fR.  \f(CW\*(C`poll\*(C'\fR defaults to \*(L"w\*(R".
.Sp
As perl is a concise language, it is often difficult to
predict when a variable will be read.  For this reason, variable
watchers should poll only for writes unless you know what you are doing.
.IP "timer" 4
.IX Item "timer"
Extra attributes: at => \f(CW$time\fR, after => \f(CW$sec\fR, interval => \f(CW$sec\fR, hard => \f(CW$bool\fR
.Sp
Generate events at particular times.
The \f(CW$time\fR and \f(CW$sec\fR are in seconds.  Fractional seconds may be used
if Time::HiRes is available.  \f(CW\*(C`at\*(C'\fR and \f(CW\*(C`after\*(C'\fR are mutually exclusive.
.Sp
\&\f(CW\*(C`at\*(C'\fR or \f(CW\*(C`after\*(C'\fR specify the initial time that the event will trigger.
Subsequent timer events occur at intervals specified by \f(CW\*(C`interval\*(C'\fR
or \f(CW\*(C`after\*(C'\fR (in that order of preference) if either was supplied.
The timer defaults to one-shot behaviour if \f(CW\*(C`interval\*(C'\fR was not specified,
or repeating behaviour if \f(CW\*(C`interval\*(C'\fR was specified; in either case this
can be overridden by providing \f(CW\*(C`repeat\*(C'\fR explicitly.
.Sp
You need to know the time at the start of today if you are trying to
set timers to trigger at day relative times.  You can find it with:
.Sp
.Vb 2
\&  use Time::Local;
\&  my $TodaySeconds = int timelocal(0,0,0,(localtime)[3,4,5]);
.Ve
.Sp
This calculation may seem a little heavy weight.  If you want to use
\&\s-1UTC\s0 rather than local time then you can use this instead:
.Sp
.Vb 1
\&  my $TodaySeconds = time \- time % 86400;
.Ve
.Sp
Beware that, due to lags in the event loop, the \f(CW\*(C`interval\*(C'\fR timeout may
already be in the past.  If the \f(CW\*(C`hard\*(C'\fR flag is set, the event will be
queued for execution relative to the last time the callback was
invoked.  However, if \f(CW\*(C`hard\*(C'\fR is false the new timeout will be
calculated relative to the current time.  \f(CW\*(C`hard\*(C'\fR defaults to false.
.IP "io" 4
.IX Item "io"
Extra attributes: fd => \f(CW$fd\fR, poll => 'rwe'
[timeout => \f(CW$seconds\fR, hard => \f(CW$bool\fR, timeout_cb => \e&code]
.Sp
The callback is invoked when the file descriptor, \f(CW\*(C`fd\*(C'\fR, has data to
be read, written, or pending exceptions.  \f(CW\*(C`fd\*(C'\fR can be a \s-1GLOB,\s0 an
IO::Handle object, or a file number (file descriptor).
\&\f(CW\*(C`poll\*(C'\fR defaults to \*(L"r\*(R".
.Sp
Note that it is your option whether to have multiple watchers per file
handle or to use a single watcher for all event conditions.
.Sp
If \f(CW\*(C`timeout\*(C'\fR is set, events are also generated regularly if no actual
I/O event occurs.
If \f(CW\*(C`timeout_cb\*(C'\fR is set then timeouts use this alternate callback instead
of the main callback.
.IP "signal" 4
.IX Item "signal"
Extra attribute: signal => \f(CW$str\fR
.Sp
Generates events based on signal arrival.  The events are not actually
generated immediately when the signal arrives: signals received are
counted and reified by \f(CW\*(C`queue_pending()\*(C'\fR or implicitly by
\&\f(CW\*(C`one_event()\*(C'\fR.  Several signals of the same type may be merged into a
single event. In such cases, the number of signals represented by a
single event is stored in the \*(L"hits\*(R" attribute.
.SS "\s-1PRIORITY\s0"
.IX Subsection "PRIORITY"
Priority is used to sort the event queue.  Meaningful priorities range
from \-1 to 6 inclusive.  Lower numbers mean higher priority (\-1 is the
highest priority and 6 is the lowest).  If multiple events get queued,
the ones with the highest priority are serviced first.  Events with
equal priority are serviced in first-in-first-out order.
.PP
.Vb 1
\&  use Event qw(PRIO_HIGH PRIO_NORMAL);   # some constants
\&
\&  LEVELS: \-1      0      1      2      3      4      5      6
\&          \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&                            PRIO_HIGH     PRIO_NORMAL
.Ve
.PP
A negative priority causes the callback to be invoked immediately upon
event occurrence.  Use this with caution.  While it may seem
advantageous to use negative priorities, they bypass the whole point
of having an event queue.
.PP
Each watcher has a \fIdefault priority\fR, assigned by its constructor:
.PP
.Vb 4
\&  io       PRIO_NORMAL
\&  signal   PRIO_HIGH
\&  timer    PRIO_NORMAL
\&  var      PRIO_NORMAL
.Ve
.PP
Default priorities are stored in ${\*(L"Event::${type}::DefaultPriority\*(R"}.
If the default priority is not satisfactory for your purposes, the
constructor options \f(CW\*(C`nice\*(C'\fR, \f(CW\*(C`async\*(C'\fR, or \f(CW\*(C`prio\*(C'\fR can be used to
adjust it.  \f(CW\*(C`nice\*(C'\fR specifies an offset from the default priority;
\&\f(CW\*(C`async\*(C'\fR forces the priority to \-1; and \f(CW\*(C`prio\*(C'\fR assigns a given
priority of your choice.  If more than one of these options are given
then \f(CW\*(C`prio\*(C'\fR overrides \f(CW\*(C`async\*(C'\fR overrides \f(CW\*(C`nice\*(C'\fR.
.SS "\s-1WATCHER CONSTRUCTOR ATTRIBUTES\s0"
.IX Subsection "WATCHER CONSTRUCTOR ATTRIBUTES"
These options are only supported as constructor arguments.
.ie n .IP "after => $seconds" 4
.el .IP "after => \f(CW$seconds\fR" 4
.IX Item "after => $seconds"
See the discussion of the timer watcher.
.ie n .IP "async => $bool" 4
.el .IP "async => \f(CW$bool\fR" 4
.IX Item "async => $bool"
If \f(CW$bool\fR then the watcher priority is set to \-1.
.ie n .IP "nice => $offset" 4
.el .IP "nice => \f(CW$offset\fR" 4
.IX Item "nice => $offset"
Offset from the default priority.
.ie n .IP "parked => $yes" 4
.el .IP "parked => \f(CW$yes\fR" 4
.IX Item "parked => $yes"
By default, watcher constructors automatically invoke the \f(CW\*(C`start()\*(C'\fR
method.  If you don't want the watcher started then request
\&\f(CW\*(C`parked=>1\*(C'\fR.
.SS "\s-1WATCHER ATTRIBUTES\s0"
.IX Subsection "WATCHER ATTRIBUTES"
.ie n .IP "at => $time" 4
.el .IP "at => \f(CW$time\fR" 4
.IX Item "at => $time"
The expiration time in the same units as the system clock.  For a
timer, \f(CW\*(C`at\*(C'\fR will usually be in the future.
.IP "cb => \e&code" 4
.IX Item "cb => &code"
.PD 0
.ie n .IP "cb => [$class_or_object, $method_name]" 4
.el .IP "cb => [$class_or_object, \f(CW$method_name\fR]" 4
.IX Item "cb => [$class_or_object, $method_name]"
.PD
The function or method to call when an event is dispatched.  The
callback is invoked with \f(CW$event\fR as its only argument.
.Sp
Perhaps you are wondering what happens if something goes wrong and an
untrapped \f(CW\*(C`die\*(C'\fR occurs within your callback?  \f(CW$Event::DIED\fR is just
for this purpose.  See the full description of \f(CW\*(C`DIED\*(C'\fR below.
.ie n .IP "cbtime => $time" 4
.el .IP "cbtime => \f(CW$time\fR" 4
.IX Item "cbtime => $time"
When the callback was invoked most recently.
.ie n .IP "data => $anything" 4
.el .IP "data => \f(CW$anything\fR" 4
.IX Item "data => $anything"
The \f(CW\*(C`data()\*(C'\fR method associates arbitrary data with a watcher.
.Sp
This method is not intended for implementers of watchers.  If you are
subclassing or implementing a watcher, consider the \f(CW\*(C`private()\*(C'\fR
method.
.ie n .IP "debug => $bool" 4
.el .IP "debug => \f(CW$bool\fR" 4
.IX Item "debug => $bool"
Debugging can be activated globally or per watcher.  When debugging is
enabled for a particular watcher, \f(CW$Event::DebugLevel\fR is treated as two
levels higher.  Levels of 1, 2, 3, or 4 give progressively more
diagnostics on \s-1STDERR.\s0
.ie n .IP "desc => $string" 4
.el .IP "desc => \f(CW$string\fR" 4
.IX Item "desc => $string"
An identifying name.  If this is not passed explicitly to the
constructor, it will be initialized with a string that attempts to
identify the location in the source code where the watcher was
constructed.
.ie n .IP "fd => $filehandle" 4
.el .IP "fd => \f(CW$filehandle\fR" 4
.IX Item "fd => $filehandle"
This attribute can accept either a perl-esque filehandle or a system
call derived file descriptor number.
.ie n .IP "hard => $bool" 4
.el .IP "hard => \f(CW$bool\fR" 4
.IX Item "hard => $bool"
Determines how repeating timers (or timeouts) are recalculated.  The
timer is restarted either before or after the callback depending on
whether it is true or false, respectively.  In long-running callbacks
this can make a significant difference.
.ie n .IP "interval => $seconds" 4
.el .IP "interval => \f(CW$seconds\fR" 4
.IX Item "interval => $seconds"
How long between repeating timeouts.  The \f(CW\*(C`at\*(C'\fR attribute is
recalculated using \f(CW\*(C`interval\*(C'\fR upon callback return.
.ie n .IP "max => $seconds" 4
.el .IP "max => \f(CW$seconds\fR" 4
.IX Item "max => $seconds"
The maximum number of seconds to wait before triggering the callback.
Similar to a \f(CW\*(C`timeout\*(C'\fR.
.ie n .IP "max_cb_tm => $seconds" 4
.el .IP "max_cb_tm => \f(CW$seconds\fR" 4
.IX Item "max_cb_tm => $seconds"
The maximum number of seconds to spend in a callback.  If a callback
uses more time then it is aborted.  Defaults to 1 sec.  This feature
is normally disabled.  See Event::Stats.
.ie n .IP "min => $seconds" 4
.el .IP "min => \f(CW$seconds\fR" 4
.IX Item "min => $seconds"
Enforce a minimum number of seconds between triggering events.
.ie n .IP "poll => $bits" 4
.el .IP "poll => \f(CW$bits\fR" 4
.IX Item "poll => $bits"
Determines which kinds of events are of interest.  This attribute can
be set with either strings or bit constants.  The bit constants are
available via 'use Event::Watcher qw(R W E T);'.
.Sp
.Vb 6
\&  string constant description
\&  \-\-\-\-\-\- \-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   \*(Aqr\*(Aq     R      read
\&   \*(Aqw\*(Aq     W      write
\&   \*(Aqe\*(Aq     E      exception
\&   \*(Aqt\*(Aq     T      timeout
.Ve
.Sp
Thus, both of these statements enable interest in read:
.Sp
.Vb 2
\&  $w\->poll($w\->poll . \*(Aqr\*(Aq);
\&  $w\->poll($w\->poll | R);
.Ve
.Sp
A given type of watcher may support all or a subset of the available
events.
.ie n .IP "prio => $level" 4
.el .IP "prio => \f(CW$level\fR" 4
.IX Item "prio => $level"
Changes the watcher's priority to the given level.  Events generated
by a watcher usually inherit the priority of the watcher.
.ie n .IP "private => $anything" 4
.el .IP "private => \f(CW$anything\fR" 4
.IX Item "private => $anything"
Use the \f(CW\*(C`private()\*(C'\fR method to associate arbitrary data with a
watcher.  This method is intended for implementers of watchers or
watcher subclasses.  Each caller's package accesses its own private
attribute.
.ie n .IP "reentrant => $bool" 4
.el .IP "reentrant => \f(CW$bool\fR" 4
.IX Item "reentrant => $bool"
By default, callbacks are allowed to invoke \f(CW\*(C`sweep\*(C'\fR or \f(CW\*(C`loop\*(C'\fR which
in turn may invoke the same callback again recursively.  This can be
useful but can also be confusing.  Moreover, if you keep reentering
callbacks you will quickly run out of stack space. Disable this
feature per watcher by setting reentrant to false.  This will cause
the watcher to be suspended during recursive calls to \f(CW\*(C`sweep\*(C'\fR or
\&\f(CW\*(C`loop\*(C'\fR.
.ie n .IP "repeat => $bool" 4
.el .IP "repeat => \f(CW$bool\fR" 4
.IX Item "repeat => $bool"
The repeat flag controls whether the callback should either be
one-shot or continue waiting for new events.  The default setting
depends on the type of watcher.  \fIio\fR, \fIsignal\fR, and \fIvar\fR default
to true.
.ie n .IP "signal => $str" 4
.el .IP "signal => \f(CW$str\fR" 4
.IX Item "signal => $str"
The callback is invoked after the specified signal is received.  The
\&\f(CW$str\fR string should be something like '\s-1INT\s0' or '\s-1QUIT\s0'.  Also see the
documentation for \f(CW%SIG\fR.
.Sp
A given signal can be handled by \f(CW%SIG\fR or Event, but not both at the
same time.  Event handles the signal as long as there is at least one
active watcher. If all watchers for the signal are cancelled or
stopped then Event sets the signal handler to \s-1SIG_DFL.\s0
.ie n .IP "suspend => $bool" 4
.el .IP "suspend => \f(CW$bool\fR" 4
.IX Item "suspend => $bool"
Stop looking for events.  Running events are allowed to complete, but
queued events are cancelled.
.Sp
Suspend is for debugging.  If you suspend all watchers in an
application then you can examine the complete state unchanged for as
long as you like without worrying about timer expirations.  If you
actually wish to stop a watcher then use the \f(CW\*(C`stop()\*(C'\fR method.
.ie n .IP "timeout => $seconds" 4
.el .IP "timeout => \f(CW$seconds\fR" 4
.IX Item "timeout => $seconds"
The number of seconds before a watcher times out.
.IP "timeout_cb => \e&code" 4
.IX Item "timeout_cb => &code"
.PD 0
.ie n .IP "timeout_cb => [$class_or_object, $method_name]" 4
.el .IP "timeout_cb => [$class_or_object, \f(CW$method_name\fR]" 4
.IX Item "timeout_cb => [$class_or_object, $method_name]"
.PD
This is an optional attribute for use when it is desired that timeouts
be serviced in a separate code path than normal events.  When this
attribute is unset, timeouts are serviced by \f(CW\*(C`cb\*(C'\fR.
.ie n .IP "var => $ref" 4
.el .IP "var => \f(CW$ref\fR" 4
.IX Item "var => $ref"
A reference to the variable being watched.
.SS "\s-1EVENT ATTRIBUTES\s0"
.IX Subsection "EVENT ATTRIBUTES"
.ie n .IP "got => $bits" 4
.el .IP "got => \f(CW$bits\fR" 4
.IX Item "got => $bits"
\&\f(CW\*(C`got\*(C'\fR is available in the callback of watchers with \f(CW\*(C`poll\*(C'\fR.
\&\f(CW\*(C`got\*(C'\fR is in the same format as \f(CW\*(C`poll\*(C'\fR except that it gives what
kind of event actually happened.  In contrast, \f(CW\*(C`poll\*(C'\fR is just an
indication of interest.
.ie n .IP "hits => $int" 4
.el .IP "hits => \f(CW$int\fR" 4
.IX Item "hits => $int"
Signals in quick succession can be clumped into a single event.
The number of signals clumped together is indicated by this attribute.
This is always one for event types which don't clump.
.ie n .IP "prio => $level" 4
.el .IP "prio => \f(CW$level\fR" 4
.IX Item "prio => $level"
Be aware that this priority can differ from the watcher's
priority. For instance, the watcher's priority may have changed since
the event was generated.  Moreover, the C extension \s-1API\s0 offers the
freedom to queue events of arbitrary priority.
.ie n .IP "w => $watcher" 4
.el .IP "w => \f(CW$watcher\fR" 4
.IX Item "w => $watcher"
This method return the event's watcher.  It is read-only.
.SS "Customization and Exceptions"
.IX Subsection "Customization and Exceptions"
.IP "\(bu" 4
\&\f(CW$Event::DebugLevel\fR
.Sp
Enables progressively more debugging output.  Meaningful levels range
from 1 (least output) to 5 (most output). Also see \f(CW\*(C`debug\*(C'\fR.
.IP "\(bu" 4
\&\f(CW$Event::DIED\fR
.Sp
When \f(CW\*(C`loop\*(C'\fR or \f(CW\*(C`sweep\*(C'\fR is called, an exception context is
established for the duration of event processing. If an exception is
detected then \f(CW$Event::DIED\fR is invoked.  The default hook uses
\&\f(CW\*(C`warn\*(C'\fR to output the exception.  After the \s-1DIED\s0 handler completes,
event processing continues as if nothing happened.
.Sp
If you'd like more detailed output you can install the verbose
handler:
.Sp
.Vb 1
\&  $Event::DIED = \e&Event::verbose_exception_handler;
.Ve
.Sp
Or you can write your own.  The handler is invoked like this:
.Sp
.Vb 1
\&  $Event::DIED\->($event, $@);
.Ve
.Sp
If you do not want to continue looping after an error, you can do
something like this:
.Sp
.Vb 4
\&  $Event::DIED = sub {
\&    Event::verbose_exception_handler(@_);
\&    Event::unloop_all();
\&  };
.Ve
.IP "\(bu" 4
Event\->add_hooks(key => sub { ... }, ...);
.Sp
The bulk of Event's implementation is in C for \fBmaximum\fR performance.
The \f(CW\*(C`add_hooks\*(C'\fR method allows insertion of perl code at key points in
the optimized event processing core.  While flexible, this can hurt
performance *significantly*.  If you want customization *and*
performance, please see the C \s-1API.\s0
.Sp
Currently support hooks are detailed as follows:
.Sp
.Vb 6
\&  hook          purpose
\&  \-\-\-\-\-\-\-\-\-\-\-\-\- \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  prepare       returns minimum time to block (timeable)
\&  check         assess state after normal return from select/poll
\&  asynccheck    check for signals, etc
\&  callback      invoked before each event callback
.Ve
.SH "C API"
.IX Header "C API"
Event also has a direct \s-1API\s0 for callbacks written exclusively in C.
See Event::MakeMaker.
.SH "WHAT ABOUT THREADS?"
.IX Header "WHAT ABOUT THREADS?"
Event loops and threads are two different solutions to the same
problem: asynchronous processing.  Event loops have been around since
the beginning of computing.  They are well understood and proven to be
a good solution for many applications.
.PP
While event loops make use of basic operating system services, the
bulk of their implementation is usually outside the kernel.  While an
event loop may appear to do many things in parallel, it does not, even
on multiprocessor hardware.  Actions are always dispatched
sequentially.  This implies that long running callbacks must be
avoided because otherwise event processing is halted.
.PP
Event loops work well when actions are short and to the point.
Long-running tasks must be broken into short steps and scheduled for
execution.  Some sort of a state machine is usually required.  While a
big, complex application server is usually simpler to implement in a
multithreaded fashion, a web browser can easily get by without
threads.  Consider a \s-1JPEG\s0 file download and render.  When some new
bytes are available they are sorted to the right place on the screen.
Only a little state must be kept to keep track of how much has been
rendered and to process subsequent incoming bytes.
.PP
Threads can either substitute for an event loop or complement it.
Threads are similar to processes in that the operating system manages
task switching for you.  However, the difference is that all threads
share the same address space.  This is good and bad.  Higher
performance can be achieved but since data is shared between threads,
extreme care must be taken to access or modify global data.  The
operating system can switch threads at any moment or can execute
multiple threads simultaneously.  I hope this sounds dangerous!  It
is!  Threads can introduce maddeningly complicated and hard to debug
synchronization problems.
.PP
Threads are like rocket fuel.  They are essential when you really need
them but most applications would be better off with a simple event
loop.  Even if threads are genuinely needed, consider confining them
to the parts of an application where truly scalable performance is
really worth the difficulty of a multithreaded implementation.  For
example, most GUIs applications do not need threads and most
scientific compute intensive problems can be isolated from event
dispatching.  On the other hand, high performance transaction servers
generally do mandate a truly multithreaded approach.
.PP
Another consideration is that threads are not quite as widely
available as event loops.  While a few forward-thinking operating
systems have offered threads since the beginning, their addition to
many popular operating systems is much more recent and some still
offer no threads support.  If portability is a requirement, one must
check that threads support is available and also carefully test a
particular threads implementation to see whether it supports the
features you need.  It is likely that all platforms will have a solid
implementation soon but at this point in history it is best to double
check.
.PP
Many suggestions by Mark Mielke <Mark.Mielke.markm@nt.com>
.SH "WHAT ABOUT NON-PREEMPTIVE THREADS?"
.IX Header "WHAT ABOUT NON-PREEMPTIVE THREADS?"
The Java language is oriented to use non-preemptive threads, yet even
Java uses an event-loop for Swing (\s-1AFAIK\s0). That is one of the reasons
I don't use Java for network-centric applications. My belief is that
the benefit of multi-threading is the gain in performance on \s-1SMP\s0
hardware.  In my view, non-preemptive threads (java green-threads) are
usually poor design.  I find them harder to work with, harder to
debug, and slower for a rather marginal gain in readability. I really
like working with a state machine.  I find it leads to more stable and
better code. It also has the benefit of abstracting away how
concurrency is achieved.
.PP
Contributed by artur@vogon\-solutions.com, 12 Jul 1999.
.SH "BUGS"
.IX Header "BUGS"
No support for epoll, or better, libevent.
.PP
The scope of events is pretty strange compared to most other perl
objects.  I'm not sure if this is a bug or a feature (\s-1OK,\s0 probably it
was a mistake).  We'll probably want to re-work things for Perl6.
.PP
The meaning of \f(CW$io\fR\->\fItimeout\fR\|(0) might change.  Use \f(CW\*(C`undef\*(C'\fR to unset
the timeout.
.PP
There seems to be some sort of bug in the global destruction phase:
.PP
.Vb 4
\&  Attempt to free unreferenced scalar during global destruction.
\&  Use of uninitialized value during global destruction.
\&  Explicit blessing to \*(Aq\*(Aq (assuming package main) during global
\&  destruction.
.Ve
.SH "THE FUTURE"
.IX Header "THE FUTURE"
Even if this module does not end up being the One and True Event Loop,
the author will insure that it is source compatible with its
successor, or arrange for gradual migration.  Back in the early days,
the Event programming \s-1API\s0 was changing at every release.  Care was
taken to allow the old \s-1API\s0 to continue to work, and the transition
was eased by printing out lots of warnings about the new usage.  So
you shouldn't sit on your hands in anticipation of the One and True
Event Loop.  Just start coding!
.SH "ALSO SEE"
.IX Header "ALSO SEE"
.IP "\(bu" 4
Useful and Fun
.Sp
Time::HiRes, NetServer::Portal, Time::Warp
.IP "\(bu" 4
Message Passing
.Sp
\&\s-1COPE, IPC::LDT,\s0 Event-tcp
.IP "\(bu" 4
\&\s-1GUI\s0
.Sp
While Tk does not yet support Event, PerlQt does.
.IP "\(bu" 4
C \s-1API\s0
.Sp
Inline
.SH "SUPPORT"
.IX Header "SUPPORT"
If you have insights or complaints then please subscribe to the
mailing list!  Send email to:
.PP
.Vb 1
\&  perl\-loop\-subscribe@perl.org
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Joshua N. Pritikin <\fIjpritikin@pobox.com\fR>
.SH "ACKNOWLEDGMENT"
.IX Header "ACKNOWLEDGMENT"
Initial 0.01 implementation by Graham Barr
<\fIgbarr@pobox.com\fR>.  Other contributors include at least
those lists below and folks mentioned in the ChangeLog.
.PP
.Vb 5
\& Gisle Aas <gisle@aas.no>
\& Uri Guttman <uri@sysarch.com>
\& Nick Ing\-Simmons <nick@ni\-s.u\-net.com> (Tk)
\& Sarathy <gsar@engin.umich.edu>
\& Jochen Stenzel <perl@jochen\-stenzel.de>
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright X 1997 Joshua Nathaniel Pritikin & Graham Barr
.PP
Copyright X 1998, 1999, 2000, 2001, 2002, 2003, 2004 Joshua Nathaniel Pritikin
.PP
All rights reserved.  This program is free software; you can
redistribute it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 869:" 4
.IX Item "Around line 869:"
Non-ASCII character seen before =encoding in 'X'. Assuming \s-1ISO8859\-1\s0
