.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Event 3"
.TH IO::Event 3 "2013-09-18" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Event \- Tied Filehandles for Nonblocking IO with Object Callbacks
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use IO::Event;
\& use IO::Event \*(Aqemulate_Event\*(Aq;
\& use IO::Event \*(AqAnyEvent\*(Aq;
\&
\& my $ioe = IO::Event\->new($filehandle);
\&
\& my $ioe = IO::Event::Socket::INET\->new( [ARGS] )
\&
\& my $ioe = IO::Event::Socket::UNIX\->new( [ARGS] )
\&
\& my $timer = IO::Event\->timer(
\&        [after => $seconds],
\&        interval => $seconds,
\&        cb => CODE);
\&
\& my $idler = IO::Event\->idle(
\&        [min => $seconds], 
\&        [max => $seconds],
\&        [reentrant => 0],
\&        cb => CODE);
\&
\& IO::Event::loop();
\&
\& IO::Event::unloop_all();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
IO::Event provides a object-based callback system for
handling nonblocking \s-1IO. \s0 The design goal is to provide a
system that just does the right thing w/o the user needing
to think about it much.
.PP
All APIs are kept as simple as possible yet at the same time,
all functionality is accesible if needed.  Simple things are
easy.  Hard things are possible.
.PP
Most of the time file handling syntax will work fine:
\&\f(CW\*(C`<$filehandle>\*(C'\fR and \f(CW\*(C`print $filehandle \*(Aqstuff\*(Aq\*(C'\fR.
.PP
IO::Event provides automatic buffering of output (with a 
callback to throttle).  It provides automatic line-at-a-time
input.
.PP
After initial setup, call \f(CW\*(C`IO::Event::loop()\*(C'\fR.
.PP
IO::Event was originally written to use Event.  IO::Event still 
defaults to using Event but it can now use AnyEvent or its
own event loop.
.SH "CHOOSING AN EVENT HANDLER"
.IX Header "CHOOSING AN EVENT HANDLER"
Until you create your first IO::Event object, you can choose
which underlying event handler to use.  The default is Event.
To choose an event handler, use one of the following lines,
import \f(CW\*(C`no_emulate_Event\*(C'\fR, \f(CW\*(C`emulate_Event\*(C'\fR, or \f(CW\*(C`AnyEvent\*(C'\fR.
.PP
.Vb 3
\& use IO::Event \*(Aqno_emulate_Event\*(Aq
\& use IO::Event \*(Aqemulate_Event\*(Aq
\& use IO::Event \*(AqAnyEvent\*(Aq
.Ve
.PP
The \f(CW\*(C`no_emulate_Event\*(C'\fR option means: use Event.  The \f(CW\*(C`emulate_Event\*(C'\fR
option means IO::Event should use its own event loop.
.PP
Why?
.PP
You should use AnyEvent if you want to have compatibility with
other event loops.  You should use \f(CW\*(C`emulate_Event\*(C'\fR if you don't
need compatibility with other event loops and you have missing-event
bugs when using Event.  You should use Event if it works for you.
.PP
The APIs are a bit different depending on which event loop you're using.
.SS "Event"
.IX Subsection "Event"
To use Event's event loop:
.PP
.Vb 1
\& use IO::Event \*(Aqno_emulate_Event\*(Aq;
.Ve
.PP
or just:
.PP
.Vb 1
\& use IO::Event
.Ve
.PP
IO::Event's definition for \f(CW\*(C`loop()\*(C'\fR, \f(CW\*(C`timer()\*(C'\fR, \f(CW\*(C`idle()\*(C'\fR and 
\&\f(CW\*(C`unloop_all()\*(C'\fR all default to the Event version unless
\&\f(CW\*(C`emulate_Event\*(C'\fR or \f(CW\*(C`AnyEvent\*(C'\fR have been imported.  This allows you to
easily switch back and forth between Event's \s-1API\s0 and
the others.
.SS "AnyEvent"
.IX Subsection "AnyEvent"
To use AnyEvent's select loop, import \f(CW\*(C`AnyEvent\*(C'\fR.
.PP
.Vb 1
\& use IO::Event \*(AqAnyEvent\*(Aq;
.Ve
.PP
You can use AnyEvent's \s-1API\s0 directly or you can use IO::Event's 
emulated APIs: \f(CW\*(C`IO::Event::loop()\*(C'\fR, \f(CW\*(C`IO::Event::unloop()\*(C'\fR, \f(CW\*(C`IO::Event::timer()\*(C'\fR,
and \f(CW\*(C`IO::Event::idle()\*(C'\fR.  These behave like Event's routines of the
same name but use AnyEvent underneath.
.PP
During testing, using the pure-perl event loop of AnyEvent::Impl::Perl from
AnyEvent version 5.271, some read events were dropped.  To work around this, a synthetic 
read-ready event is dispatched for all connected read filehandles every two
seconds.  Turn this off or adjust its frequency by changing 
\&\f(CW$IO::Event::AnyEvent::lost_event_hack\fR.  A numeric value is the time (in seconds)
between dispatching read events.  A false value turns off this performance-sapping hack.
.PP
AnyEvent only provides basic support for \fIidle()\fR events: it promises to invoke
them \*(L"every now and then\*(R".
.ie n .SS """emulate_Event"""
.el .SS "\f(CWemulate_Event\fP"
.IX Subsection "emulate_Event"
To use IO::Event's own select loop, import \f(CW\*(C`emulate_Event\*(C'\fR.
.PP
.Vb 1
\& use IO::Event \*(Aqemulate_Event\*(Aq;
.Ve
.PP
IO::Event does not provide a complete emulation of everything that
Event does.  It provides the full timer \s-1API: \s0
.PP
.Vb 1
\& my $timer = IO::Event::timer( [ARGS] )
.Ve
.PP
instead of
.PP
.Vb 1
\& my $timer = Event::timer( [ARGS] )
.Ve
.PP
However it does not provide timer events on filehandles, nor does
it provide events for signals, or variable accesses.
.PP
Use \f(CW\*(C`IO::Event::loop()\*(C'\fR instead of \f(CW\*(C`Event::loop()\*(C'\fR.   Use 
\&\f(CW\*(C`IO::Event::unloop_all()\*(C'\fR instead of \f(CW\*(C`Event::unloop_all()\*(C'\fR.
Use \f(CW\*(C`IO::Event::idle()\*(C'\fR instead of \f(CW\*(C`Event::idle()\*(C'\fR.
It does not provide any other methods or functions from
Event.   If you need them, please send a patch.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.ie n .IP "IO::Event\->new($filehandle, [ $handler, [ $options ]])" 4
.el .IP "IO::Event\->new($filehandle, [ \f(CW$handler\fR, [ \f(CW$options\fR ]])" 4
.IX Item "IO::Event->new($filehandle, [ $handler, [ $options ]])"
The basic \f(CW\*(C`new\*(C'\fR constructor takes a filehandle and returns
a psuedo-filehandle.  Treat the IO::Event object as
a filehandle.  Do not use the original filehandle without
good reason (let us know if you find a good reason so we
can fix the problem).
.Sp
The handler is the class or object where you provide callback
functions to handle \s-1IO\s0 events.  It defaults to the package
of the calling context.
.Sp
If present, \f(CW$options\fR is a hash reference with the following
possible keys:
.RS 4
.IP "description" 13
.IX Item "description"
A text description of this filehandle.  Used for debugging and
error messages.
.IP "read_only" 13
.IX Item "read_only"
Set to true if this is a read-only filehandle.  Do not accept output.
.IP "write_only" 13
.IX Item "write_only"
Set to true if this is a write-only filehandle.  Do not attept to read.
.IP "autoread" 13
.IX Item "autoread"
Set to 0 if this should not be an auto-read filehandle.
.RE
.RS 4
.RE
.IP "IO::Event::Socket::INET\->new( [\s-1ARGS\s0] )" 4
.IX Item "IO::Event::Socket::INET->new( [ARGS] )"
This constructor uses IO::Socket::INET\->\fInew()\fR to create a 
socket using the \s-1ARGS\s0 provided.  It returns an 
IO::Event object.
.Sp
The handler defaults as above or can be set with an
additional pseudo-parameter for IO::Socket::UNIX\->\fInew()\fR: 
\&\f(CW\*(C`Handler\*(C'\fR.  A description for the socket can be provided
with an additional psuedo-parameter: \f(CW\*(C`Description\*(C'\fR.
.IP "IO::Event::Socket::UNIX\->new( [\s-1ARGS\s0] )" 4
.IX Item "IO::Event::Socket::UNIX->new( [ARGS] )"
This constructor uses IO::Socket::UNIX\->\fInew()\fR to create a 
socket using the \s-1ARGS\s0 provided.  It returns an 
IO::Event object.
.Sp
The handler defaults as above or can be set with an
additional pseudo-parameter for IO::Socket::UNIX\->\fInew()\fR: 
\&\f(CW\*(C`Handler\*(C'\fR.  A description for the socket can be provided
with an additional psuedo-parameter: \f(CW\*(C`Description\*(C'\fR.
.SH "MANDATORY HANDLERS"
.IX Header "MANDATORY HANDLERS"
These handler methods must be available in the handler
object/class if the situation in which they would be
called arises.
.ie n .IP "ie_input($handler, $ioe, $input_buffer_reference)" 4
.el .IP "ie_input($handler, \f(CW$ioe\fR, \f(CW$input_buffer_reference\fR)" 4
.IX Item "ie_input($handler, $ioe, $input_buffer_reference)"
Invoked when there is fresh data in the input buffer.  The 
input can be retrieved via directly reading it from
\&\f(CW$$input_buffer_reference\fR or via \f(CW\*(C`read()\*(C'\fR from the
\&\f(CW$ioe\fR filehandle, or by using a variety of standard
methods for getting data:
.Sp
.Vb 8
\&        <$ioe>                  like IO::Handle
\&        $ioe\->get()             like Data::LineBuffer
\&        $ioe\->read()            like IO::Handle
\&        $ioe\->sysread()         like IO::Handle
\&        $ioe\->getline()         like IO::Handle
\&        $ioe\->getlines()        like IO::Handle
\&        $ioe\->getsome()         see below
\&        $ioe\->ungets()          like FileHandle::Unget
.Ve
.Sp
At end-of-file, ie_input will only be invoked once.  There
may or may not be data in the input buffer.
.ie n .IP "ie_connection($handler, $ioe)" 4
.el .IP "ie_connection($handler, \f(CW$ioe\fR)" 4
.IX Item "ie_connection($handler, $ioe)"
Invoked when a \fIlisten()\fRing socket is ready to \fIaccept()\fR.
It should call accept:
.Sp
.Vb 5
\&        sub ie_connection
\&        {
\&                my ($pkg, $ioe) = @_;
\&                my $newfh = $ioe\->accept()
\&        }
.Ve
.ie n .IP "ie_read_ready($handler, $ioe, $underlying_file_handle)" 4
.el .IP "ie_read_ready($handler, \f(CW$ioe\fR, \f(CW$underlying_file_handle\fR)" 4
.IX Item "ie_read_ready($handler, $ioe, $underlying_file_handle)"
If autoreading is turned off then this will be invoked.
.ie n .IP "ie_werror($handler, $ioe, $output_buffer_reference)" 4
.el .IP "ie_werror($handler, \f(CW$ioe\fR, \f(CW$output_buffer_reference\fR)" 4
.IX Item "ie_werror($handler, $ioe, $output_buffer_reference)"
A write error has occured when trying to drain the write
buffer.  Provide an empty subroutine if you don't care.
.SH "OPTIONAL HANDLERS"
.IX Header "OPTIONAL HANDLERS"
These handler methods will be called if they are defined
but it is not required that they be defined.
.ie n .IP "ie_eof($handler, $ioe, $input_buffer_reference)" 4
.el .IP "ie_eof($handler, \f(CW$ioe\fR, \f(CW$input_buffer_reference\fR)" 4
.IX Item "ie_eof($handler, $ioe, $input_buffer_reference)"
This is invoked when the read-side of the filehandle has
been closed by its source.
.IP "ie_output" 4
.IX Item "ie_output"
This is invoked when data has just been written to the 
underlying filehandle.
.IP "ie_outputdone" 4
.IX Item "ie_outputdone"
This is invoked when all pending data has just been written
to the underlying filehandle.
.IP "ie_connected" 4
.IX Item "ie_connected"
This is invoked when a \f(CW\*(C`connect()\*(C'\fR completes.
.ie n .IP "ie_connect_failed($handler, $ioe, $error_code)" 4
.el .IP "ie_connect_failed($handler, \f(CW$ioe\fR, \f(CW$error_code\fR)" 4
.IX Item "ie_connect_failed($handler, $ioe, $error_code)"
This is invoked when a \f(CW\*(C`connect()\*(C'\fR fails.  For a timeout,
the error code will be \s-1ETIMEOUT.\s0
.ie n .IP "ie_died($handler, $ioe, $method, $@)" 4
.el .IP "ie_died($handler, \f(CW$ioe\fR, \f(CW$method\fR, $@)" 4
.IX Item "ie_died($handler, $ioe, $method, $@)"
If another handler calls \f(CW\*(C`die\*(C'\fR then ie_died will be called
with the IO::Event object, the name of the method just
invoked, and the die string.  If no \fIie_died()\fR callback exists
then execution will terminate.
.IP "ie_timer" 4
.IX Item "ie_timer"
This is invoked for timer events.
.IP "ie_exception" 4
.IX Item "ie_exception"
Invoked when an exceptional condition arises on the 
underlying filehandle
.ie n .IP "ie_outputoverflow($handler, $ioe, $overflowing, $output_buffer_reference)" 4
.el .IP "ie_outputoverflow($handler, \f(CW$ioe\fR, \f(CW$overflowing\fR, \f(CW$output_buffer_reference\fR)" 4
.IX Item "ie_outputoverflow($handler, $ioe, $overflowing, $output_buffer_reference)"
Invoked when there is too much output data and the output buffers
are overflowing.  You can take some action to generate less output.
This will be invoked exactly once (with \f(CW$overflowing\fR == 1) when 
there is too much data in the buffer and then exactly once again
(with \f(CW$overflowing\fR == 0) when there is no longer too much data in the
buffer.
.SH "METHODS"
.IX Header "METHODS"
In addition to methods described in detail below, the following
methods behave like their \f(CW\*(C`IO\*(C'\fR (mostly \f(CW\*(C`IO::Socket\*(C'\fR) counterparts
(except for being mostly non-blocking...):
.PP
.Vb 9
\&        connect
\&        listen
\&        open
\&        read
\&        sysread
\&        syswrite
\&        print
\&        eof
\&        shutdown
.Ve
.PP
Through \s-1AUTOLOAD \s0(see the \s-1SUBSTITUTED METHODS\s0 section) methods 
are passed to underlying \f(CW\*(C`Event\*(C'\fR objects:
.PP
.Vb 3
\&        loop
\&        unloop
\&        and many more...
.Ve
.PP
Through \s-1AUTOLOAD \s0(see the \s-1SUBSTITUTED METHODS\s0 section) methods 
are passed to underlying \f(CW\*(C`IO\*(C'\fR objects:
.PP
.Vb 7
\&        fileno
\&        stat
\&        truncate
\&        error
\&        opened
\&        untaint
\&        and many more...
.Ve
.PP
IO::Event defines its own methods too:
.ie n .IP "\->accept($handler, %options)" 4
.el .IP "\->accept($handler, \f(CW%options\fR)" 4
.IX Item "->accept($handler, %options)"
\&\fIaccept()\fR is nearly identical to the normal \fIIO::Socket::accept()\fR
method except that instead of optionally passing a class
specifier for the new socket, you optionally pass a 
handler object or class.   The returned filehandle is an
IO::Event object.
.Sp
Supported options:
.RS 4
.IP "description" 4
.IX Item "description"
Sets the description for the new socket
.IP "autoread" 4
.IX Item "autoread"
Set to 0 if you do not want auto-read
.RE
.RS 4
.RE
.IP "\->can_read($amount)" 4
.IX Item "->can_read($amount)"
Returns true if \f(CW$amount\fR bytes worth of input is available for
reading.  Note: this does not return true at \s-1EOF\s0 so be careful not
to hang forever at \s-1EOF.\s0
.IP "\->getsome($amount)" 4
.IX Item "->getsome($amount)"
Returns \f(CW$amount\fR bytes worth of input or undef if the request
can't be filled.  Returns what it can at \s-1EOF.\s0
.IP "\->\fIget()\fR" 4
.IX Item "->get()"
\&\fIget()\fR is like \fIgetline()\fR except that it pre\-\fIchomp()\fRs the
results and assumes the input_record_separator is \*(L"\en\*(R".
This is like \fIget()\fR from Data::LineBuffer.
.IP "\->\fIunget()\fR" 4
.IX Item "->unget()"
Push \fIchomp()\fRed lines back into the input buffer.
This is like \fIunget()\fR from Data::LineBuffer.
.IP "\->\fIungetline()\fR, \->\fIxungetc()\fR, \->\fIungets()\fR" 4
.IX Item "->ungetline(), ->xungetc(), ->ungets()"
This is what \fIungetc()\fR should be: it pushes a string back into
the input buffer.  This is unlike IO::Handle\->ungetc which
takes an ordinal and pushes one character back into the 
the input buffer.  This is like FileHandle::Unget.
.IP "\->handler($new_handler)" 4
.IX Item "->handler($new_handler)"
Sets the handler object/class if \f(CW$new_handler\fR is provided.
Returns the old handler.
.IP "\->\fIfilehandle()\fR" 4
.IX Item "->filehandle()"
Returns the underlying \f(CW\*(C`IO::Handle\*(C'\fR.
.IP "\->\fIevent()\fR" 4
.IX Item "->event()"
Returns the underling \f(CW\*(C`Event\*(C'\fR.
.IP "\->listener($listening)" 4
.IX Item "->listener($listening)"
Used to note that a filehandle is being used to listen
for connections (instead of receiving data).  A passed
parameter of 0 does the opposite.  Returns the old value.
This is mostly used internally in IO::Event.
.IP "\->input_record_separator($new_sep)" 4
.IX Item "->input_record_separator($new_sep)"
IO::Handle doesn't allow input_record_separator's on a per filehandle
basis.  IO::Event does.  If you don't ever set a filehandle's input
record separator, then it contineously defaults to the current value
of \f(CW$/\fR.  If you set it, then it will use your value and never
look at \f(CW$/\fR again.
.IP "\->readevents($readevents)" 4
.IX Item "->readevents($readevents)"
Get/set listening for read-ready events on the underlying
filehandle.  This could be used by ie_outputoverflow to
control input flows.
.IP "\->output_bufsize($output_bufsize)" 4
.IX Item "->output_bufsize($output_bufsize)"
Get/set the size of the output buffer.
.IP "\->autoread($autoread)" 4
.IX Item "->autoread($autoread)"
Get/set automatic reading if data when data can be read.
Without autoread turned on, the input buffer ins't filled
and none of the read methods will work.  The point of this
is for working with non-data filehandles.  This is an
experts-only method that kinda defeats the purpose of
this module.  This would be necessary using \fIrecv()\fR to get
data.
.IP "\->\fIdrain()\fR" 4
.IX Item "->drain()"
Used to start looking for write-ready events on the underlying
filehandle.  In normal operation this is handled automatically.
Deprecated: use \f(CWwriteevents(1)\fR instead.
.IP "\->reentrant($reentrant)" 4
.IX Item "->reentrant($reentrant)"
Get/set reentrant callbacks.  By default, IO::Event avoids making
reentrant callbacks.  This is good because your code is less likely
to break.  This is bad because you won't learn about things right away.
For example, you will not learn the the output buffer is overflowing
during \fIprint()\fR.  You'll have to wait for the output buffer to begin
draining to find out.  This could be a problem.
.IP "\->\fIclose()\fR" 4
.IX Item "->close()"
If there is output buffered, close will be delayed until the output
buffer drains.
.IP "\->forceclose" 4
.IX Item "->forceclose"
Close close immediately, even if there is output buffered.
.IP "\->ie_desc([new description])" 4
.IX Item "->ie_desc([new description])"
Returns (and sets) the text description of the filehandle.  For debugging.
.SH "TIMER API"
.IX Header "TIMER API"
The following timer construction arguments are supported by IO::Event's
emulated event loop and IO::Event's \s-1API\s0 on top of AnyEvent:
.IP "cb" 4
.IX Item "cb"
A callback to invoke when the timer goes off.  The callback can either be
a \s-1CODE\s0 reference or an array reference.  If it's an array reference, the
array should be a two element tuple: the first element is an object and the
second object is a method to invoke on the object.  The only argument to
the method call a reference to the timer object:
.Sp
.Vb 2
\& my ($object, $method) = @{$timer\->{cb}}
\& $object\->$method($timer)
.Ve
.IP "at" 4
.IX Item "at"
A time at which to invoke the callback.
.IP "interval" 4
.IX Item "interval"
An interval, in seconds between repeat invocations of the callback.
.IP "after" 4
.IX Item "after"
The interval until the first invocation of the callback.  After that,
invoke every \fIinterval\fR.
.PP
The following methods (from Event) are supported on timer objects:
\&\fIstart()\fR, \fIagain()\fR, \fInow()\fR, \fIstop()\fR, \fIcancel()\fR, \fIis_cancelled()\fR, \fIis_running()\fR,
\&\fIis_suspended()\fR, pending.
.SH "IDLE API"
.IX Header "IDLE API"
The following idle construction arguments are supported by IO::Event's
emulated event loop and IO::Event's \s-1API\s0 on top of AnyEvent:
.IP "cb" 4
.IX Item "cb"
A callback to invoke when the event loop is idle.  The callback can either be
a \s-1CODE\s0 reference or an array reference.  If it's an array reference, the
array should be a two element tuple: the first element is an object and the
second object is a method to invoke on the object.
.Sp
.Vb 2
\& my ($object, $method) = @{$timer\->{cb}}
\& $object\->$method();
.Ve
.IP "min" 4
.IX Item "min"
The minimum time between invocations of the callback.
.IP "max" 4
.IX Item "max"
The maximum time between invocations of the callback.
.PP
The following methods (from Event) are supported on idle objects:
\&\fIstart()\fR, \fIagain()\fR, \fInow()\fR, \fIstop()\fR, \fIcancel()\fR, \fIis_cancelled()\fR, \fIis_running()\fR,
\&\fIis_suspended()\fR, pending.
.SH "SUBSTITUED METHODS"
.IX Header "SUBSTITUED METHODS"
Any method invocations that fail because the method isn't defined
in IO::Event will by tried twice more: once using trying for a
method on the inner (hidden) filehandle and once more trying 
for a method on the Event object that's used to create the select
loop for this module.
.PP
This dispatch is now deprecated with the choice of event handlers.
.SH "EXAMPLE SERVER"
.IX Header "EXAMPLE SERVER"
.Vb 1
\&        # This is a tcp line echo server
\&
\&        my $listener = IO::Event::Socket::INET\->new(
\&                Listen => 10,
\&                Proto => \*(Aqtcp\*(Aq,
\&                LocalPort => 2821,
\&        );
\&
\&        Event::loop();
\&
\&        sub ie_connection
\&        {
\&                my ($pkg, $lstnr) = @_;
\&                my $client = $lstnr\->accept();
\&                printf "accepted connection from %s:%s\en",
\&                        $client\->peerhost, $client\->peerport;
\&        }
\&
\&        sub ie_input
\&        {
\&                my ($pkg, $client, $ibufref) = @_;
\&                print $client <$client>;
\&        }
.Ve
.SH "SYSREAD and EOF"
.IX Header "SYSREAD and EOF"
\&\fIsysread()\fR is incompatible with \fIeof()\fR because \fIeof()\fR uses
\&\fIgetc()\fR.  Most of the time this isn't a problem.  In other words,
some of the time this is a problem: lines go missing.
.PP
For this reason, IO::Event never uses \fIsysread()\fR.  In fact,
if you ask it to do a \fIsysread()\fR it does a \fIread()\fR for you instead.
.PP
On the other hand, at the current time no problems with syswrite
have come to light and IO::Event uses syswrite and never any other
form of write/print etc.
.SH "DESTRUCTION"
.IX Header "DESTRUCTION"
IO::Event keeps copies of all of its registered filehandles.  If
you want to close a filehandle, you'll need to actually call close
on it.
.SH "DATA STRUCTURE"
.IX Header "DATA STRUCTURE"
The filehandle object itself is a funny kind of hash reference.
If you want to use it to store your own data, you can.  Please 
don't use hash keys that begin \f(CW\*(C`ie_\*(C'\fR or \f(CW\*(C`io_\*(C'\fR as those are the
prefixes used by \f(CW\*(C`IO::Event\*(C'\fR and \f(CW\*(C`IO::Socket\*(C'\fR.
.PP
The syntax is kinda funny:
.PP
.Vb 1
\&        ${*$filehandle}{\*(Aqyour_hash_key\*(Aq}
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For a different \s-1API\s0 on top of IO::Event, 
see IO::Event::Callback.  It uses IO::Event but provides 
a simpler and perhaps easier-to-use \s-1API.\s0
.PP
The following perl modules do something that is kinda similar
to what is being done here:
.PP
AnyEvent::Handle,
AnyEvent::AIO,
\&\s-1IO::AIO\s0,
IO::Multiplex,
IO::NonBlocking,
IO::Select
Event,
\&\s-1POE\s0,
POE::Component::Server::TCP,
Net::Socket::NonBlock,
Net::Server::Multiplex,
NetServer::Generic
.PP
The \s-1API\s0 borrows most heavily from IO::Multiplex.  IO::Event
uses Event.pm and thus can be used in programs that are already
using Event or \s-1POE.\s0
.PP
Since the original writing of IO::Event, AnyEvent has been
released and now AnyEvent::AIO and <AnyEvent:Handle> should be
considered the only good alternatives to IO::Event.
.PP
For an example program using IO::Event, see IO::Event::rinetd
which used to be included in this package.
.SH "BUGS"
.IX Header "BUGS"
The test suite only covers 40% of the code.  The module is used
by its author and seems solid.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2002\-2009 David Muir Sharnoff <muir@idiom.org>.
Copyright (C) 2011\-2013 Google, Inc.
This module may be used/copied/etc on the same terms as Perl itself.
.PP
This module is packaged for Fedora by Emmanuel Seyman <emmanuel@seyman.fr>
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 476:" 4
.IX Item "Around line 476:"
\&'=item' outside of any '=over'
