.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Structure::Util 3"
.TH Data::Structure::Util 3 "2008-03-09" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Structure::Util \- Change nature of data within a structure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use Data::Structure::Util qw(
\&      has_utf8 utf8_off utf8_on unbless get_blessed get_refs
\&      has_circular_ref circular_off signature
\&    );
\&
\&    # get the objects in the data structure
\&    my $objects_arrayref = get_blessed( $data );
\&
\&    # unbless all objects
\&    unbless( $data );
\&
\&    if ( has_circular_ref( $data ) ) {
\&        print "Removing circular ref!\en";
\&        circular_off( $data );
\&    }
\&
\&    # convert back to latin1 if needed and possible
\&    utf8_off( $data ) if defined has_utf8( $data );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Data::Structure::Util\*(C'\fR is a toolbox to manipulate the data inside a
data structure. It can process an entire tree and perform the operation
requested on each appropriate element.
.PP
For example: It can transform all strings within a data structure to
utf8 or transform any utf8 string back to the default encoding. It can
remove the blessing on any reference. It can collect all the objects or
detect if there is a circular reference.
.PP
It is written in C for decent speed.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
All Data::Structure::Util functions operate on a whole tree. If you pass
them a simple scalar then they will operate on that one scalar. However,
if you pass them a reference to a hash, array, or scalar then they will
iterate though that structure and apply the manipulation to all
elements, and in turn if they are references to hashes, arrays or
scalars to all their elements and so on, recursively.
.PP
For speed reasons all manipulations that alter the data structure do in\-
place manipulation meaning that rather than returning an altered copy of
the data structure the passed data structure which has been altered.
.SS "Manipulating Data Structures"
.IX Subsection "Manipulating Data Structures"
.IP "has_circular_ref($ref)" 4
.IX Item "has_circular_ref($ref)"
This function detects if the passed data structure has a circular
reference, that is to say if it is possible by following references
contained in the structure to return to a part of the data structure you
have already visited. Data structures that have circular references will
not be automatically reclaimed by Perl's garbage collector.
.Sp
If a circular reference is detected the function returns a reference
to an element within circuit, otherwise the function will return a
false value.
.Sp
If the version of perl that you are using supports weak references then
any weak references found within the data structure will not be
traversed, meaning that circular references that have had links
successfully weakened will not be returned by this function.
.IP "circular_off($ref)" 4
.IX Item "circular_off($ref)"
Detects circular references in \f(CW$ref\fR (as above) and weakens a link in
each so that they can be properly garbage collected when no external
references to the data structure are left.
.Sp
This means that one (or more) of the references in the data structure
will be told that the should not count towards reference counting. You
should be aware that if you later modify the data structure and leave
parts of it only 'accessible' via weakened references that those parts
of the data structure will be immediately garbage collected as the
weakened references will not be strong enough to maintain the connection
on their own.
.Sp
The number of references weakened is returned.
.IP "get_refs($ref)" 4
.IX Item "get_refs($ref)"
Examine the data structure and return a reference to flat array that
contains one copy of every reference in the data structure you passed.
.Sp
For example:
.Sp
.Vb 4
\&    my $foo = {
\&        first  => [ "inner", "array", { inmost => "hash" } ],
\&        second => \e"refed scalar",
\&    };
\&
\&    use Data::Dumper;
\&    # tell Data::Dumper to show nodes multiple times
\&    $Data::Dumper::Deepcopy = 1;
\&    print Dumper get_refs( $foo );
\&
\&    $VAR1 = [
\&        { \*(Aqinmost\*(Aq => \*(Aqhash\*(Aq },
\&        [ \*(Aqinner\*(Aq, \*(Aqarray\*(Aq, { \*(Aqinmost\*(Aq => \*(Aqhash\*(Aq } ],
\&        \e\*(Aqrefed scalar\*(Aq,
\&        {
\&            \*(Aqfirst\*(Aq  => [ \*(Aqinner\*(Aq, { \*(Aqinmost\*(Aq => \*(Aqhash\*(Aq }, \*(Aqarray\*(Aq ],
\&            \*(Aqsecond\*(Aq => \e\*(Aqrefed scalar\*(Aq
\&        }
\&    ];
.Ve
.Sp
As you can see, the data structure is traversed depth first, so the
top most references should be the last elements of the array.  See
get_blessed($ref) below for a similar function for blessed objects.
.IP "signature($ref)" 4
.IX Item "signature($ref)"
Returns a md5 of the passed data structure.  Any change at all to the
data structure will cause a different md5 to be returned.
.Sp
The function examines the structure, addresses, value types and flags
to generate the signature, meaning that even data structures that
would look identical when dumped with Data::Dumper produce different
signatures:
.Sp
.Vb 1
\&    $ref1 = { key1 => [] };
\&
\&    $ref2 = $ref1;
\&    $ref2\->{key1} = [];
\&
\&    # this produces the same result, as they look the same
\&    # even though they are different data structures
\&    use Data::Dumper;
\&    use Digest::MD5 qw(md5_hex);
\&    print md5_hex( Dumper( $ref1 ) ), " ", md5_hex( Dumper( $ref2 ) ), "\en";
\&    # cb55d41da284a5869a0401bb65ab74c1 cb55d41da284a5869a0401bb65ab74c1
\&
\&    # this produces differing results
\&    use Data::Structure::Util qw(signature);
\&    print signature( $ref1 ), " ", signature( $ref2 ), "\en";
\&    # 5d20c5e81a53b2be90521167aefed9db 8b4cba2cbae0fec4bab263e9866d3911
.Ve
.SS "Object Blessing"
.IX Subsection "Object Blessing"
.IP "unbless($ref)" 4
.IX Item "unbless($ref)"
Remove the blessing from any objects found within the passed data
structure. For example:
.Sp
.Vb 4
\&    my $foo = {
\&        \*(Aqa\*(Aq => bless( { \*(Aqb\*(Aq => bless( {}, "c" ), }, "d" ),
\&        \*(Aqe\*(Aq => [ bless( [], "f" ), bless( [], "g" ), ]
\&    };
\&
\&    use Data::Dumper;
\&    use Data::Structure::Util qw(unbless);
\&    print Dumper( unbless( $foo ) );
\&
\&    $VAR1 = {
\&        \*(Aqa\*(Aq => { \*(Aqb\*(Aq => {} },
\&        \*(Aqe\*(Aq => [ [], [] ]
\&    };
.Ve
.Sp
Note that the structure looks inside blessed objects for other
objects to unbless.
.IP "get_blessed($ref)" 4
.IX Item "get_blessed($ref)"
Examine the data structure and return a reference to flat array that
contains every object in the data structure you passed.  For example:
.Sp
.Vb 4
\&    my $foo = {
\&        \*(Aqa\*(Aq => bless( { \*(Aqb\*(Aq => bless( {}, "c" ), }, "d" ),
\&        \*(Aqe\*(Aq => [ bless( [], "f" ), bless( [], "g" ), ]
\&    };
\&
\&    use Data::Dumper;
\&    # tell Data::Dumper to show nodes multiple times
\&    $Data::Dumper::Deepcopy = 1;
\&    use Data::Structure::Util qw(get_blessed);
\&    print Dumper( get_blessed( $foo ) );
\&
\&    $VAR1 = [
\&        bless( {}, \*(Aqc\*(Aq ),
\&        bless( { \*(Aqb\*(Aq => bless( {}, \*(Aqc\*(Aq ) }, \*(Aqd\*(Aq ),
\&        bless( [], \*(Aqf\*(Aq ),
\&        bless( [], \*(Aqg\*(Aq )
\&    ];
.Ve
.Sp
This function is essentially the same as \f(CW\*(C`get_refs\*(C'\fR but only returns
blessed objects rather than all objects.  As with that function the
data structure is traversed depth first, so the top most objects
should be the last elements of the array.  Note also (as shown in the
above example shows) that objects within objects are returned.
.SS "utf8 Manipulation Functions"
.IX Subsection "utf8 Manipulation Functions"
These functions allow you to manipulate the state of the utf8 flags in
the scalars contained in the data structure.  Information on the utf8
flag and it's significance can be found in Encode.
.IP "has_utf8($var)" 4
.IX Item "has_utf8($var)"
Returns \f(CW$var\fR if the utf8 flag is enabled for \f(CW$var\fR or any scalar
that a data structure passed in \f(CW$var\fR contains.
.Sp
.Vb 2
\&    print "this will be printed"  if defined has_utf8( "\ex{1234}" );
\&    print "this won\*(Aqt be printed" if defined has_utf8( "foo bar" );
.Ve
.Sp
Note that you should not check the truth of the return value of this
function when calling it with a single scalar as it is possible to
have a string \*(L"0\*(R" or "" for which the utf8 flag set; Since \f(CW\*(C`undef\*(C'\fR
can never have the utf8 flag set the function will never return a
defined value if the data structure does not contain a utf8 flagged
scalar.
.IP "_utf8_off($var)" 4
.IX Item "_utf8_off($var)"
Recursively disables the utf8 flag on all scalars within \f(CW$var\fR.  This
is the same the \f(CW\*(C`_utf8_off\*(C'\fR function of Encode but applies to any
string within \f(CW$var\fR.  The data structure is converted in-place, and
as a convenience the passed variable is returned from the function.
.Sp
This function makes no attempt to do any character set conversion to
the strings stored in any of the scalars in the passed data structure.
This means that if perl was internally storing any character as
sequence of bytes in the utf8 encoding each byte in that sequence will
then be henceforth treated as a character in it's own right.
.Sp
For example:
.Sp
.Vb 5
\&    my $emoticons = { smile => "\ex{236a}" };
\&    use Data::Structure::Util qw(_utf8_on);
\&    print length( $emoticons\->{smile} ), "\en";    # prints 1
\&    _utf8_off( $emoticons );
\&    print length( $emoticons\->{smile} ), "\en";    # prints 3
.Ve
.IP "_utf8_on($var)" 4
.IX Item "_utf8_on($var)"
Recursively enables the utf8 flag on all scalars within \f(CW$var\fR.  This is
the same the \f(CW\*(C`_utf8_on\*(C'\fR function of Encode but applies to any
string within \f(CW$var\fR. The data structure is converted in-place and as
a convenience the passed variable is returned from the function.
.Sp
As above, this makes no attempt to do any character set conversion
meaning that unless your string contains the valid utf8 byte sequences
for the characters you want you are in trouble.  \fBIn some cases
incorrect byte sequences can segfault perl\fR.  In particular, the
regular expression engine has significant problems with invalid utf8
that has been incorrectly marked as utf8.  You should know what you
are doing if you are using this function; Consider using the Encode
module as an alternative.
.Sp
Contrary example to the above:
.Sp
.Vb 5
\&    my $emoticons = { smile => "\e342\e230\e272" };
\&    use Data::Structure::Util qw(_utf8_on);
\&    print length( $emoticons\->{smile} ), "\en";    # prints 3
\&    _utf8_on( $emoticons );
\&    print length( $emoticons\->{smile} ), "\en";    # prints 1
.Ve
.IP "utf8_on($var)" 4
.IX Item "utf8_on($var)"
This routine performs a \f(CW\*(C`sv_utf8_upgrade\*(C'\fR on each scalar string in
the passed data structure that does not have the utf8 flag turned on.
This will cause the perl to change the method it uses internally to
store the string from the native encoding (normally Latin\-1 unless
locales come into effect) into a utf8 encoding and set the utf8 flag
for that scalar.  This means that single byte letters will now be
represented by multi-byte sequences.  However, as long as the \f(CW\*(C`use
bytes\*(C'\fR pragma is not in effect the string will be the same length as
because as far as perl is concerned the string still contains the same
number of characters (but not bytes).
.Sp
This routine is significantly different from \f(CW\*(C`_utf8_on\*(C'\fR; That routine
assumes that your string is encoded in utf8 but was marked (wrongly)
in the native encoding.  This routine assumes that your string is
encoded in the native encoding and is marked that way, but you'd
rather it be encoded and marked as utf8.
.IP "utf8_off($var)" 4
.IX Item "utf8_off($var)"
This routine performs a \f(CW\*(C`sv_utf8_downgrade\*(C'\fR on each scalar string in
the passed data structure that has the utf8 flag turned on.  This will
cause the perl to change the method it uses internally to store the
string from the utf8 encoding into a the native encoding (normally
Latin\-1 unless locales are used) and disable the utf8 flag for that
scalar.  This means that multiple byte sequences that represent a
single character will be replaced by one byte per character. However,
as long as the \f(CW\*(C`use bytes\*(C'\fR pragma is not in effect the string will be
the same length as because as far as perl is concerned the string
still contains the same number of characters (but not bytes).
.Sp
Please note that not all strings can be converted from utf8 to the
native encoding; In the case that the utf8 character has no
corresponding character in the native encoding Perl will die with
\&\*(L"Wide character in subroutine entry\*(R" exception.
.Sp
This routine is significantly different from \f(CW\*(C`_utf8_off\*(C'\fR; That
routine assumes that your string is encoded in utf8 and that you want
to simply mark it as being in the native encoding so that perl will
treat every byte that makes up the character sequences as a character
in it's own right in the native encoding.  This routine assumes that
your string is encoded in utf8, but you want it each character that is
currently represented by multi-byte strings to be replaced by the
single byte representation of the same character.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode, Scalar::Util, Devel::Leak, Devel::LeakTrace
.PP
See the excellent article
http://www.perl.com/pub/a/2002/08/07/proxyobject.html from Matt
Sergeant for more info on circular references.
.PP
The development version of this module and others can be found at
http://opensource.fotango.com/svn/trunk/Data\-Structure\-Util/
.SH "BUGS"
.IX Header "BUGS"
\&\f(CW\*(C`signature()\*(C'\fR is sensitive to the hash randomisation algorithm
.PP
This module only recurses through basic hashes, lists and scalar
references.  It doesn't attempt anything more complicated.
.SH "THANKS TO"
.IX Header "THANKS TO"
James Duncan and Arthur Bergman who helped me and found a name for
this module.  Leon Brocard and Richard Clamp have provided invaluable
help to debug this module.  Mark Fowler rewrote large chunks of the
documentation and patched a few bugs.
.SH "AUTHOR"
.IX Header "AUTHOR"
This release by Andy Armstrong <andy@hexten.net>
.PP
Originally by Pierre Denis <pdenis@fotango.com>
.PP
http://opensource.fotango.com/
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003, 2004 Fotango \- All Rights Reserved.
.PP
This module is released under the same license as Perl itself.
